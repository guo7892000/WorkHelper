### 实例-物品入出库统计
```
CREATE OR REPLACE PROCEDURE P_GD_GET_DLR_IN_OUT_TOTAL(
  PPART_NO         IN VARCHAR2, --物品编号
  PPART_NAME       IN VARCHAR2, --物品名称
  PWAREHOUSE_ID    IN VARCHAR2, --仓库编号
  PPLACE_ID        IN VARCHAR2, --仓位编号
  PPART_TYPE       IN VARCHAR2, --物品类别编码
  PPART_PREPERTY   IN VARCHAR2, --物品属性编码
  PPART_BRAND_CODE IN VARCHAR2, --物品品牌
  PBEGIN_DATE      IN VARCHAR2, --单据开始时间,数据格式：YYYY-MM-DD
  PEND_DATE        IN VARCHAR2, --单据结束时间,数据格式：YYYY-MM-DD
  PDLR_ID          IN VARCHAR2, --网点编码
  PVARIETY_CODE    IN VARCHAR2, --物品品种分类
  PINT_COUNT       OUT NUMBER, --输出的记录条数
  PRET_CUR         OUT SYS_REFCURSOR --输出参数，数据类型为引用游标的类型
) IS
  /*******************************************************************************************
  * 对象名称：专营店入出库统计过程
  * 创建作者：
  * 创建日期：
  ********************************************************************************************/

  --声明变量
  VBEGIN_DATE    DATE; --统计开始时间
  VEND_DATE      DATE; --统计结束时间
  VCAL_BEGINTIME DATE; --物品单据开始计算时间，即最近一次月结的最后入出时间
  VBALANCE_MONTH VARCHAR(6); --小于开始日期的最大月结月份,如没有，则取期初月结，数据格式：200906

  V_STR_SQL VARCHAR2(4000) := ''; --拼接的sql语句

  V_STRERROR VARCHAR2(2000) := '';

BEGIN

  --开始时间和结束时间处理
  SELECT TO_DATE(PBEGIN_DATE, 'YYYY-MM-DD'),
         TO_DATE(PEND_DATE, 'YYYY-MM-DD') + INTERVAL '1' DAY
    INTO VBEGIN_DATE, VEND_DATE
    FROM DUAL;

  /*取得小于开始统计时间的月结月份*/
  SELECT MAX(M.BALANCE_MONTH)
    INTO VBALANCE_MONTH
    FROM T_GD_BU_DLR_STORE_MONTH M
   WHERE M.MONTH_END_DATE < VBEGIN_DATE
     AND M.DLR_ID = PDLR_ID;

  IF VBALANCE_MONTH IS NULL THEN
    --不存在开始时间前的月结
    --查询最初的一次月结
    SELECT MIN(M.BALANCE_MONTH)
      INTO VBALANCE_MONTH
      FROM T_GD_BU_DLR_STORE_MONTH M
     WHERE M.DLR_ID = PDLR_ID;
  END IF;

  /*获取月结年月的月份最后时间(确定最后入出时间)。比如：201111 -> 2011-11-30 23:59:59*/
  IF VBALANCE_MONTH IS NULL THEN
    VCAL_BEGINTIME := VBEGIN_DATE;
  ELSE
    SELECT TO_DATE(TO_CHAR(LAST_DAY(TO_DATE(VBALANCE_MONTH, 'YYYY-MM')),
                           'YYYY-MM-DD') || ' 23:59:59',
                   'YYYY-MM-DD hh24:mi:ss')
      INTO VCAL_BEGINTIME
      FROM DUAL;
  END IF;
  ----插入本次查询的所有物品信息到临时表中去
  V_STR_SQL := 'INSERT INTO T_GD_IN_OUT_TOTAL_TMP
(SELECT SYS_GUID(), PART.*, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
FROM (SELECT D.DLR_CODE,
D.DLR_SHORT_NAME,
A.PART_NO,
L.PART_NAME,
L.PART_BRAND_NAME AS BRAND_NAME,
L.UNIT,
W.WAREHOUSE_NAME,
PL.PLACE_CODE
FROM T_GD_BU_DLR_STORAGE A
JOIN V_PA_QUERY_PART_LIST L ON　L.PART_NO = A.PART_NO AND L.PART_ID = A.PART_ID
JOIN T_MDM_ORG_DLR D ON A.DLR_ID = D.DLR_ID
JOIN T_GD_DB_DLR_WAREHOUSE W ON W.WAREHOUSE_ID = A.WAREHOUSE_ID AND W.DLR_ID = A.DLR_ID
LEFT JOIN T_GD_DB_DLR_PLACE PL ON PL.PLACE_ID = A.PLACE_ID AND PL.DLR_ID = A.DLR_ID
WHERE 1 = 1';

  V_STR_SQL := V_STR_SQL || 'AND A.DLR_ID = ''' || PDLR_ID || '''';
  --查询条件拼接
  IF PPART_NO IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND L.PART_NO LIKE ''%' || PPART_NO ||
                 '%''';
    V_STR_SQL := V_STR_SQL || ' AND A.PART_NO LIKE ''%' || PPART_NO ||
                 '%''';
  END IF;
  IF PPART_NAME IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND L.PART_NAME LIKE ''%' || PPART_NAME ||
                 '%''';
  END IF;
  IF PWAREHOUSE_ID IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND A.WAREHOUSE_ID = ''' || PWAREHOUSE_ID || '''';
  END IF;
  IF PPLACE_ID IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND A.PLACE_ID = ''' || PPLACE_ID || '''';
  END IF;
  IF PPART_TYPE IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND L.PART_TYPE_ID = ''' || PPART_TYPE || '''';
  END IF;
  IF PPART_PREPERTY IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND L.PART_PROPERTY_CODE = ''' ||
                 PPART_PREPERTY || '''';
  END IF;
  IF PVARIETY_CODE IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND L.PART_VARIETY_CODE IN (' ||
                 PVARIETY_CODE || ')';
  END IF;
  IF PPART_BRAND_CODE IS NOT NULL THEN
    V_STR_SQL := V_STR_SQL || ' AND L.PART_BRAND_CODE = ''' ||
                 PPART_BRAND_CODE || '''';
  END IF;
  --结束标志
  V_STR_SQL := V_STR_SQL || ') PART)';

  EXECUTE IMMEDIATE V_STR_SQL; --执行动态SQL

  --所有入库明细数据
   INSERT INTO T_GD_IN_STORE_TOTAL_TMP
   (SELECT /*+ merge(VID) */SYS_GUID(),
   VID.DLR_CODE,
   VID.DLR_SHORT_NAME,
   VID.PART_BRAND_NAME,
   VID.PART_NO,
   VID.PART_NAME,
   VID.UNIT,
   VID.WAREHOUSE_NAME,
   VID.PLACE_CODE,
   VID.IN_STORE_DATE,
   VID.BILL_TYPE,
   VID.IN_STORE_QTY,
   VID.STORE_COST_AMOUNT,
   VID.STORE_PRICE_AMOUNT
   FROM V_PA_IN_STORE_DETAIL VID
   JOIN V_PA_QUERY_PART_LIST L ON VID.PART_NO = L.PART_NO
   JOIN T_GD_IN_OUT_TOTAL_TMP C ON VID.PART_NO = C.PART_NO
   WHERE VID.DLR_ID = PDLR_ID
   AND VID.IN_STORE_DATE >= VCAL_BEGINTIME
   AND VID.IN_STORE_DATE <= VEND_DATE);

  --插入所有出库明细（针对1、2、3、9是销售，有利润计算）
  INSERT INTO T_GD_OUT_STORE_TOTAL_TMP
    SELECT /*+ leading(c) no_merge(vod) */
     SYS_GUID(),
     VOD.DLR_CODE,
     VOD.DLR_SHORT_NAME,
     VOD.PART_BRAND_NAME,
     VOD.PART_NO,
     VOD.PART_NAME,
     VOD.UNIT,
     VOD.WAREHOUSE_NAME,
     VOD.PLACE_CODE,
     VOD.OUT_STORE_DATE,
     VOD.BILL_TYPE,
     VOD.OUT_STORE_QTY,
     VOD.STORE_COST_AMOUNT,
     VOD.STORE_PRICE_AMOUNT,
     VOD.SALE_AMOUNT,
     VOD.PART_PROFIT, /*总利润*/
     CASE
       WHEN VOD.BILL_TYPE IN ('3') THEN
        VOD.SALE_AMOUNT_NOTAX - VOD.STORE_COST_AMOUNT
       WHEN VOD.BILL_TYPE IN ('103') THEN
        - (VOD.SALE_AMOUNT_NOTAX - VOD.STORE_COST_AMOUNT)
     END DBLR, /*调拨总利润*/
     CASE
       WHEN VOD.BILL_TYPE IN ('1') THEN
        VOD.SALE_AMOUNT_NOTAX - VOD.STORE_COST_AMOUNT
       WHEN VOD.BILL_TYPE IN ('101') THEN
        - (VOD.SALE_AMOUNT_NOTAX - VOD.STORE_COST_AMOUNT)
     END WXLR, /*维修利润*/
     CASE
       WHEN VOD.BILL_TYPE IN ('2', '9') THEN
        VOD.SALE_AMOUNT_NOTAX - VOD.STORE_COST_AMOUNT
       WHEN VOD.BILL_TYPE IN ('102', '109') THEN
        - (VOD.SALE_AMOUNT_NOTAX - VOD.STORE_COST_AMOUNT)
     END JPXSLR /*精品销售利润*/
      FROM V_PA_OUT_STORE_DETAIL VOD
      JOIN T_GD_IN_OUT_TOTAL_TMP C
        ON VOD.PART_NO = C.PART_NO
     WHERE VOD.DLR_ID = PDLR_ID
       AND VOD.OUT_STORE_DATE >= VCAL_BEGINTIME
       AND VOD.OUT_STORE_DATE <= VEND_DATE;
  
  ---1、更新期初数据
  MERGE INTO T_GD_IN_OUT_TOTAL_TMP IOT
  USING (SELECT DD.PART_NO,
                SUM(DD.BEG_QTY) AS BEG_QTY,
                SUM(DD.BEG_CB) AS BEG_CB,
                SUM(DD.BEG_HSCB) AS BEG_HSCB
           FROM ( ---最近一次月结数据
                 SELECT MD.PART_NO,
                         CAST(NVL(SUM(MD.END_QTY), 0.0000) AS NUMBER(18, 4)) AS BEG_QTY,
                         CAST(NVL(SUM(MD.END_COST), 0.000000) AS NUMBER(18, 6)) AS BEG_CB,
                         CAST(NVL(SUM(MD.END_AMOUNT), 0.000000) AS
                              NUMBER(18, 6)) AS BEG_HSCB
                   FROM T_GD_BU_DLR_STORE_MONTH   M,
                         T_GD_BU_DLR_STORE_MONTH_D MD,
                         T_GD_IN_OUT_TOTAL_TMP     IOT
                  WHERE M.STORE_MONTH_ID = MD.STORE_MONTH_ID
                    AND MD.PART_NO = IOT.PART_NO
                    AND M.BALANCE_MONTH = VBALANCE_MONTH
                    AND M.DLR_ID = PDLR_ID
                  GROUP BY MD.PART_NO
                 --最近一次月结最后入出时间至统计开始时间的入库数据
                 UNION ALL
                 SELECT PART_NO,
                         CAST(NVL(SUM(IN_STORE_QTY), 0.0000) AS NUMBER(18, 4)) AS BEG_QTY,
                         CAST(NVL(SUM(IN_COST_AMOUNT), 0.000000) AS
                              NUMBER(18, 6)) AS BEG_CB,
                         CAST(NVL(SUM(IN_PRICE_AMOUNT), 0.000000) AS
                              NUMBER(18, 6)) AS BEG_HSCB
                   FROM T_GD_IN_STORE_TOTAL_TMP
                  WHERE 1 = 1
                    AND CREATED_DATE >= VCAL_BEGINTIME
                    AND CREATED_DATE < VBEGIN_DATE
                  GROUP BY PART_NO
                 --最近一次月结最后入出时间至统计开始时间的出库数据
                 UNION ALL
                 SELECT PART_NO,
                         CAST(-NVL(SUM(OUT_SOTRE_QTY), 0.0000) AS NUMBER(18, 4)) AS BEG_QTY,
                         CAST(-NVL(SUM(OUT_COST_AMOUNT), 0.000000) AS
                              NUMBER(18, 6)) AS BEG_CB,
                         CAST(-NVL(SUM(OUT_PRICE_AMOUNT), 0.000000) AS
                              NUMBER(18, 6)) AS BEG_HSCB
                   FROM T_GD_OUT_STORE_TOTAL_TMP
                  WHERE 1 = 1
                    AND CREATED_DATE >= VCAL_BEGINTIME
                    AND CREATED_DATE < VBEGIN_DATE
                  GROUP BY PART_NO) DD
          GROUP BY DD.PART_NO) IOT1
  ON (IOT.PART_NO = IOT1.PART_NO)
  WHEN MATCHED THEN
    UPDATE
       SET IOT.BEG_QTY          = IOT1.BEG_QTY,
           IOT.BEG_COST_AMOUNT  = IOT1.BEG_CB,
           IOT.BEG_PRICE_AMOUNT = IOT1.BEG_HSCB;

  ---2、更新入库数据
  MERGE INTO T_GD_IN_OUT_TOTAL_TMP IOT
  USING (SELECT TID.PART_NO,
                CAST(NVL(SUM(IN_STORE_QTY), 0) AS NUMBER(18, 4)) AS IN_QTY,
                CAST(NVL(SUM(IN_COST_AMOUNT), 0) AS NUMBER(18, 6)) AS IN_CB,
                CAST(NVL(SUM(IN_PRICE_AMOUNT), 0) AS NUMBER(18, 6)) AS IN_HSCB
           FROM T_GD_IN_STORE_TOTAL_TMP TID
          WHERE TID.CREATED_DATE >= VBEGIN_DATE
            AND TID.CREATED_DATE < VEND_DATE
          GROUP BY PART_NO) IOT1
  ON (IOT.PART_NO = IOT1.PART_NO)
  WHEN MATCHED THEN
    UPDATE
       SET IOT.IN_STORE_QTY    = IOT1.IN_QTY,
           IOT.IN_COST_AMOUNT  = IOT1.IN_CB,
           IOT.IN_PRICE_AMOUNT = IOT1.IN_HSCB;

  ---3、更新出库数据
  MERGE INTO T_GD_IN_OUT_TOTAL_TMP IOT
  USING (SELECT TOD.PART_NO,
                CAST(NVL(SUM(OUT_SOTRE_QTY), 0) AS NUMBER(18, 4)) AS OUT_QTY,
                CAST(NVL(SUM(OUT_COST_AMOUNT), 0) AS NUMBER(18, 6)) AS OUT_CB,
                CAST(NVL(SUM(OUT_PRICE_AMOUNT), 0) AS NUMBER(18, 6)) AS OUT_HSCB,
                CAST(NVL(SUM(OUT_SALE_AMOUNT), 0) AS NUMBER(18, 6)) AS OUT_HSJE,
                CAST(NVL(SUM(TOTAL_PROFIT), 0) AS NUMBER(18, 6)) AS ZLR,
                CAST(NVL(SUM(DLR_FLIT_PROFIT), 0) AS NUMBER(18, 6)) AS DBLR,
                CAST(NVL(SUM(DLR_REPAIR_PROFIT), 0) AS NUMBER(18, 6)) AS WXLR,
                CAST(NVL(SUM(DLR_ACCE_PROFIT), 0) AS NUMBER(18, 6)) AS JPXSLR
           FROM T_GD_OUT_STORE_TOTAL_TMP TOD
          WHERE TOD.CREATED_DATE >= VBEGIN_DATE
            AND TOD.CREATED_DATE < VEND_DATE
          GROUP BY PART_NO) IOT1
  ON (IOT.PART_NO = IOT1.PART_NO)
  WHEN MATCHED THEN
    UPDATE
       SET IOT.OUT_SOTRE_QTY     = IOT1.OUT_QTY,
           IOT.OUT_COST_AMOUNT   = IOT1.OUT_CB,
           IOT.OUT_PRICE_AMOUNT  = IOT1.OUT_HSCB,
           IOT.OUT_SALE_AMOUNT   = IOT1.OUT_HSJE,
           IOT.TOTAL_PROFIT      = IOT1.ZLR,
           IOT.DLR_FLIT_PROFIT   = IOT1.DBLR,
           IOT.DLR_REPAIR_PROFIT = IOT1.WXLR,
           IOT.DLR_ACCE_PROFIT   = IOT1.JPXSLR;

  ---4、更新期末数据
  UPDATE T_GD_IN_OUT_TOTAL_TMP
     SET END_QTY          = CAST(BEG_QTY + IN_STORE_QTY - OUT_SOTRE_QTY AS
                                 NUMBER(18, 4)), --期末数量
         END_COST_PRICE = CASE
                            WHEN BEG_QTY + IN_STORE_QTY - OUT_SOTRE_QTY = 0 THEN
                             0.000000
                            ELSE
                             CAST((BEG_COST_AMOUNT + IN_COST_AMOUNT -
                                  OUT_COST_AMOUNT) /
                                  (BEG_QTY + IN_STORE_QTY - OUT_SOTRE_QTY) AS
                                  NUMBER(18, 6))
                          END, --期末不含税总成本单价
         END_COST_AMOUNT  = CAST(BEG_COST_AMOUNT + IN_COST_AMOUNT -
                                 OUT_COST_AMOUNT AS NUMBER(18, 6)), --期末不含税总成本
         END_PRICE_AMOUNT = CAST(BEG_PRICE_AMOUNT + IN_PRICE_AMOUNT -
                                 OUT_PRICE_AMOUNT AS NUMBER(18, 6)); --期末含税总成本

  --给返回的游标变量赋值
  OPEN PRET_CUR FOR
    SELECT ROWNUM AS ROWNO,
           IOT.*,
           A.PART_TYPE_CODE || '|' || A.PART_TYPE_NAME AS PART_TYPE,
           A.PART_VARIETY_NAME,
           A.PART_PROPERTY_NAME
      FROM T_GD_IN_OUT_TOTAL_TMP IOT
      JOIN V_PA_QUERY_PART_LIST A
        ON A.PART_NO = IOT.PART_NO
    ;
  --查询的记录数
  SELECT COUNT(1) INTO PINT_COUNT FROM T_GD_IN_OUT_TOTAL_TMP;
  --删除数据
  DELETE FROM T_GD_IN_OUT_TOTAL_TMP;
  DELETE FROM T_GD_IN_STORE_TOTAL_TMP;
  DELETE FROM T_GD_OUT_STORE_TOTAL_TMP;

  COMMIT; ---不能提交，提交后是返回不了游标结果的

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    V_STRERROR := CASE
                    WHEN (SQLERRM IS NOT NULL AND LENGTHB(SQLERRM) > 1020) THEN
                     SUBSTRB(SQLERRM, 0, 1020)
                    ELSE
                     SQLERRM
                  END;
    RAISE_APPLICATION_ERROR(-20999, V_STRERROR);
END;
/

```

