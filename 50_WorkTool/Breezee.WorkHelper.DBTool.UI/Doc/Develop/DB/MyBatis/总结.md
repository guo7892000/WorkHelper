## MyBatis总结
### MyBatis中${}和#{}的区别
1.先看#{}解析为一个JDBC预编译语句（prepared statement）的参数标记符,把参数部分用占位符 ? 代替。动态解析为:	
select * from t_user where username = ?;	
而传入的参数将会经过PreparedStatement方法的强制类型检查和安全检查等处理，最后作为一个合法的字符串传入。	
在#{}预处理之后可以预防SQL注入传入username 为 a‘or’1=1，使用#{},经过sql动态解析和预编译,会把单引号转义为 ’ 那么sql最终解析为:	
select * from t_user where username = "a\' or \'1=1 ";	
2.再看${}这种方式只会做简单的字符串替换，在动态SQL解析阶段将会进行变量替换,假如传递的参数为51mn,最终处理结果如下:	
select * from t_user where username = '51mn' ;	
${} 预编译之前就已经被替换,有被注入的风险。如果传入的username 为 a‘or’1=1,那么使用 ${} 处理后直接替换字符串的sql就解析为:	
select * from t_user where username = 'a' or '1=1' ;	
所有的用户信息都会被查询出来了。

### 让写在源码中或者资源文件目录中的配置文件生效
需要在pom.xml中增加以下配置：  
```
<build>		
    <resources>		
        <resource>		
            <directory>src/main/java</directory>		
            <includes>		
                <include>**/*.xml</include>		
                <include>**/*.properties</include>		
                <include>**/*.yaml</include>		
                <include>**/*.yml</include>		
            </includes>		
        </resource>		
        <resource>		
            <directory>src/main/resources</directory>		
            <includes>		
                <include>**/*.xml</include>		
                <include>**/*.properties</include>		
                <include>**/*.yaml</include>		
                <include>**/*.yml</include>		
            </includes>		
        </resource>		
    </resources>		
</build>			
```

### mybatis中#{0}和#{arg0}的区别，xml中如何使用mapper接口的参数
在mybatis早的版本（3.4.2之前）中，如果Mapper接口中的方法的参数上没有使用注解指定参数名@Param("")，则可以按照参数的顺序，在xml文件中使用#{0}、#{1}、#{2}、#{3}…来获取到参数中的数据。		
举例：		
Mapper接口：
`User getUserBys(int id,String name);	`	
xml文件：  
```
<select id="getUserBys" resultType="com.model.User">		
        select * from user where id = #{0} and name=#{1}		
</select>
```
在mybatis后来的版本（3.4.2之后）中，使用arg0来代替0。		
xml文件：  
```
<select id="getUserBys" resultType="com.model.User">		
        select * from user where id = #{arg0} and name=#{arg1}		
</select>
```
注意：上面两种方法都属于位置传递		
建议		
为了避免不必要的麻烦，我们可以使用值传递的方式，在Mapper类中使用@Param("")注解，xml中使用的话，直接通过名字找到。		
Mapper接口：  
```
User getUserBys(@Param("id") int id,@Param("name") String name);		
xml文件：		
<select id="getUserBys" resultType="com.model.User">		
        select * from user where id = #{id} and name=#{name}		
</select>	
```
扩展		
对于集合来说，mybatis有默认的参数名字，比如List类型的可以通过list获取、数组类型的可以通过array获取。举个例子，接口的参数名为idList，在xml中要用到这个参数，可以使用list获取。		
Mapper接口：
`public List<User> findByIdList(List<Integer> idList);`		
xml：
```
<select id="findByIdList" resultType="com.example.bean.User">		
	SELECT id, name, password, address, enable	
	FROM user	
	<where>	
        <if test="list!= null and list.size() > 0">		
            id IN		
            <foreach collection="list" item="ietm" index="index" open="(" separator="," close=")">		
                #{item}		
            </foreach>		
        </if>		
	</where>	
</select>		
```
### mybatis的复杂sql查询
在利用mybatis做查询的时候，一般返回结果用resulttype，这种情况必须是查询的结果在对应 的pojo类中有对应的，一般都是单表查询，但是对于一些复杂的情况，
比如需要用到多表查询的时候，resultType不再适用，此时一般用resultMap来表示返回的结果。
resultMap类似于一个hashmap，里面的数据库中的字段与pojo类中的字段的映射。
```
<resultMap   id="VideoResultMap"type="video">
<!--
id 指定查询列的唯一标示
column  数据库字段的名称
property    pojo类的名称
-->
<id      column="id" property="id" jdbcType="INTEGER"/>
<result  column="video_tile" property="title"    jdbcType="VARCHAR"/>
<result column="summary" property="summary" jdbcType="VARCHAR"/>
<result column="cover_img"   property="cover Img" jdbcType="VARCHAR"/>
</resultMap>
<select   id="selectBaseFieldByIdwithResultMap" resultMap="VideoResultMap">
select id,title as video_tile,summary,cover_img from video where id=#{video_id} 
</select>
```
**associate的使用（一对一关联查询）**	
对象里面包含一个其他对象：	
如video是一个pojo类，但是其属性里面有一个user对象，但是user也是一个pojo类；	
associate里面就是对象里面关联的对象；	
```
<resultMap  id="VideoOrderResultMap" type="Videoorder">
<id         column="id" property="id"/>
<result     column="user_id" property="userId"/>
<result     column="out_trade_no" property="outTradeNo"/>
<result     column="create_time" property="createTime"/>
<result     column="state" property="state"/>
<result     column="total_fee" property="totalFee"/>
<result     column="video_id" property="videoId"/>
<result     column="video_title" property="videoTitle"/>
<result     column="video_img" property="videoImg"/>

<!--
association      配置属性一对一
property 对应videoOrder里面的user属性名
javaType 这个属性的类型
-->
<association property="user" javaType="user">
<id      property="id"    column="user_id"/>
<result  property="name" column="name"/>
<result  property="headImg" column="head_img"/>
<result  property="createTime" column="create_time"/>
<result  property="phone" column="phone"/>
</association>
</resultMap>    
```
**复杂查询之 collection（一对多查询）**	
比如User对象里面有一个List<Order> list 对象，既user里面含有多个order；
```
<resultMap id="UserOrderResultMap" type="User">
    <id property=" id" column=" id">
    <result property=" name" column=" name">
    <result property="headImg" column=" head _ img">
    <result property="createTime" column=" create _ time">
    <result property=" phone" column=" phone">

    <！--
    property 填写pojo类中集合类属性的名称
    ofType 集合里面的pojo对象
    -->
    <collection property="videoOrderList" ofType="videoOrder">
        <！--配置主键，管理 order的唯一标识-->
        <id column="order_id" property="id">
        <result column="user_id" property="userid">
        <result column="out_trade_no" property="outTradeNo">
        <result column="create_time" property="createTime">
        <result column="state" property=" state">
        <result column="total_fee" property="totalFee">
        <result column="video_id" property="videoId">
        <result column="video_title" property="videoTitle">
        <result column="video_img" property="videoImg">
    <collection/>
</resultMap>   
```