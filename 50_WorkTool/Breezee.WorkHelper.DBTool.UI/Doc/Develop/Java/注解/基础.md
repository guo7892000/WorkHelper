## 注解（Annotation）
也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、
局部变量、方法参数等的前面，用来对这些元素进行说明，注释。
根据它所起的作用，大致可分为三类： 
① 编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】  
② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】  
③ 编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 
首先一定要明白：注解他本身是没有任何作用的，比如@RequestMapping，在controller层@RequestMapping基本上可以说是必见的，
我们都知道他的作用是请求映射，通过他来设置请求的url地址，举例：将@RequestMapping("config")写在方法上，
然后我们就可以通过url地址访问到这个方法了，但是记住这并不是@RequestMapping注解的功能，
SpringMVC会通过反射将注解当中设置的属性值config拿到，然后将url和你声明注解的方法进行绑定。  
记住：注解只是用来标记，而这个注解真正的功能都是由框架通过反射来实现的。  
元数据是一个非常广泛的概念，元数据的定义也非常简单，只要是描述数据的数据都是元数据。
### 注解的属性
注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，
其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnnotation {
    int id();
    String msg();
}
```
上面代码定义了 TestAnnotation 这个注解中拥有 id 和 msg 两个属性。在使用的时候，我们应该给它们进行赋值。
赋值的方式是在注解的括号内以 value=”” 形式，多个属性之前用 ，隔开。  
```
@TestAnnotation(id=3,msg="hello annotation")
public class Test {
}
```
需要注意的是，在注解中定义属性时它的类型必须是 8 种基本数据类型外加 类、接口、注解及它们的数组。
注解中属性可以有默认值，默认值需要用 default 关键值指定。比如：
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnnotation {
    public int id() default -1;
    public String msg() default "Hi";
}
```
TestAnnotation 中 id 属性默认值为 -1，msg 属性默认值为 Hi。
### 【注解参数】 分类
根据注解参数的个数，我们可以将注解分为：标记注解、单值注解、完整注解三类。  
1. 标记注解  
标记注解不包含成员/元素。它仅用于标记声明。
其语法为：@AnnotationName()
由于这些注解不包含元素，因此不需要括号。例如：@Override  
2. 单元素注解  
单个元素注解仅包含一个元素。
其语法为：@AnnotationName(elementName = "elementValue")
如果只有一个元素，则习惯上将该元素命名为value：@AnnotationName(value = "elementValue")
在这种情况下，也可以移除元素名称。元素名称默认为value：@AnnotationName("elementValue")  
3. 多元素注解  
这些注解包含多个用逗号分隔的元素。
其语法为：@AnnotationName(element1 = "value1", element2 = "value2")
### 【注解作用】分类
预定义的注解:这几个注解都是java.lang包下的，也就是Java提供的基础注解，我们在使用的时候是不需要导包的！  
**@Deprecated**  
此注解可以用在方法，属性，类上，表示不推荐程序员使用，但是还可以使用。  
**@Override**  
它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。  
**@SuppressWarnings**  
主要用在取消一些编译器产生的警告，警告对于运行代码实际上并没有影响，但是出于部分程序员具有洁癖的嗜好，通常会采用@SuppressWarnings来消除警告。  
@SuppressWarnings(“unchecked”) [^ 抑制单类型的警告]  
@SuppressWarnings(“unchecked”,“rawtypes”) [^ 抑制多类型的警告]  
@SuppressWarnings(“all”) [^ 抑制所有类型的警告]  
**@Autowired 是Spring提供的，@Resource 是J2EE提供的**  
@Autowired与@Resource都可以用来装配bean，都可以写在字段或setter方法上。  
@Autowired默认按类型装配，默认情况下必须要求依赖对象存在，如果要允许null值，可以设置它的required属性为false。如果想使用名称装配可以结合@Qualifier注解进行使用。  
@Resource，默认按照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行名称查找。
如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。
**@SafeVarargs**
在声明具有模糊类型（比如：泛型）的可变参数的构造函数或方法时，Java编译器会报unchecked警告。鉴于这些情况，如果程序员断定声明的构造函数和方法的主体
不会对其varargs参数执行潜在的不安全的操作，可使用@SafeVarargs进行标记，这样的话，Java编译器就不会报unchecked警告。  
使用前提：  
①方法必须是由static或者final修饰的方法！  
②只能用于标记构造函数和方法。  
③只能用在可变长参数的方法上。
**@FunctionalInterface**
被@FunctionalInterface注解标记的类型表明这是一个函数接口。从概念上讲，函数接口只有一个抽象方法。也就是一旦不满足函数接口，就会报错，比如他有两个抽象方法。
@FunctionalInterface注解，只能用于接口类。其实，它的应用范围更小，只能应用于接口类型。
### 元注解
以下的注解都来源于java.lang.annotation，描述数据的数据都是元数据，描述注解的注解都是元注解！也就是这些注解只能用在修饰注解上，不能使用在其他地方，比如方法、类等等！
@Native注解除外，他的使用范围是FIELD(字段、枚举的常量)，但是@Native也是在java.lang.annotation包下！  
**@Retention**  
注解按生命周期来划分可分为3类：  
　　RetentionPolicy.SOURCE：注解只保留在源文件，当Java文件编译成class文件的时候，注解被遗弃；也就是编译时有效。  
　　RetentionPolicy.CLASS：注解被保留到class文件，但jvm加载class文件时候被遗弃，这是默认的生命周期；加载时被抛弃。  
　　RetentionPolicy.RUNTIME：注解不仅被保存到class文件中，jvm加载class文件之后，仍然存在；一直有效！  
如lombok可以通过@Data注解省去get set 方法，实际上@Data的生命周期就是RetentionPolicy.SOURCE，他是通过注解来标记这个方法要生成get set方法，然后在编译的时候直接会生成get set。生成过后，就被抛弃了。  
**@Documented**  
@Documented和@Deprecated注解长得有点像，@Deprecated是用来标注某个类或者方法不建议再继续使用，@Documented只能用在注解上，如果一个注解@B，被@Documented标注，
那么被@B修饰的类，生成文档时，会显示@B。如果@B没有被@Documented标注，最终生成的文档中就不会显示@B。这里的生成文档指的JavaDoc文档！
@Deprecated注解基本上所有框架自定义的注解都会添加，所谓javadoc其实就是JDK给我们提供的一个生成文档的工具！  
**@Target**  
@Target只能用在注解上，指定修饰的注解的使用范围。  
```
　　@Target(ElementType.TYPE) ―― 接口、类、枚举、注解
　　@Target(ElementType.FIELD) ―― 字段、枚举的常量
　　@Target(ElementType.METHOD) ―― 方法
　　@Target(ElementType.PARAMETER) ―― 方法参数
　　@Target(ElementType.CONSTRUCTOR) ―― 构造函数
　　@Target(ElementType.LOCAL_VARIABLE) ―― 局部变量
　　@Target(ElementType.ANNOTATION_TYPE) ―― 注解
　　@Target(ElementType.PACKAGE) ―― 包
```
比如@Target({ElementType.TYPE, ElementType.METHOD})，就代表着@RequestMapping可以用在 接口、类、枚举、注解上、还可以用在方法上！  
**@Inherited**
如果一个类用上了@Inherited修饰的注解，那么其子类也会继承这个注解。
当用了@Inherited修饰的注解的@Retention是RetentionPolicy.RUNTIME，则增强了继承性，在反射中可以获取得到
代码示例：
1.首先自定义一个注解使用@Inherited修饰，然后这个注解用来修饰到父类上
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Inherited
public @interface ATable {
    public String name() default "";
}
```
2.这个注解带不带@Inherited都可以，我们主要用来修饰子类
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface BTable {
    public String name() default "";
}
```
**@Repeatable**
@Repeatable 注解是用于声明其它类型注解的元注解，来表示这个声明的注解是可重复的。@Repeatable的值是另一个注解，其可以通过这个另一个注解的值来包含这个可重复的注解。代码示例：  
1.自定义Value注解  
```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(Values.class)
public @interface Value {
    String value() default "value";
}
```
2.自定义Values 注解
```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Values {
    Value[] value();
}
```
其中，@Value注解上的元注解@Repeatable中的值，使用了@Values注解，@Values注解中包含的值类型是一个@Value注解的数组！这就解释了官方文档中@Repeatable中值的使用。  
```
@Value("hello")
@Value("world")
public void test(String var1, String var2) {
    System.out.println(var1 + " " + var2);
}
```
**@Native**  
@Native注解修饰成员变量，则表示这个变量可以被本地代码引用，常常被代码生成工具使用。对于 @Native 注解不常使用，了解即可！

### 自定义注解
修饰符： 访问修饰符必须为public,不写默认为pubic；
关键字： 关键字为@interface；
注解名称： 注解名称为自定义注解的名称，使用时还会用到；
注解内容： 注解中内容，对注解的描述。
我们自定义一个注解，然后这个注解可以在entity当中的set方法上初始化值。  
第一步：自定义@Init注解   
```
@Documented
@Inherited
@Target({ElementType.FIELD, ElementType.METHOD, ElementType.TYPE})  //可以在字段、枚举的常量、方法
@Retention(RetentionPolicy.RUNTIME)
public @interface Init {
    String value() default "";
}
```
第二步：创建User类   
```
public class User {
    private String name;
    private String age;

    public String getName() {
        return name;
    }

    @Init("louis")
    public User setName(String name) {
        this.name = name;
        return this;
    }

    public String getAge() {
        return age;
    }

    @Init("22")
    public User setAge(String age) {
        this.age = age;
        return this;
    }
}
```
第三步：创建User的工厂类，所谓工厂类就是专门为了生产User对象   
```
import java.lang.reflect.Method;

public class UserFactory {
    public static User create() {
        User user = new User();
        // 获取User类中所有的方法（getDeclaredMethods也行）
        Method[] methods = User.class.getMethods();
        try {
            for (Method method : methods) {
                // 判断方法上是否存在Init注解，存在就返回true，否则返回false
                if (method.isAnnotationPresent(Init.class)) {
                    // 此方法返回该元素的注解在此元素的指定注释类型（如果存在），否则返回null
                    Init init = method.getAnnotation(Init.class);
                    // 如果Method代表了一个方法 那么调用它的invoke就相当于执行了它代表的这个方法,在这里就是给set方法赋值
                    method.invoke(user, init.value());
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
        return user;
    }
}
```
第一步：自定义@Init注解  
```
public static void main(String[] args) {
    User user = UserFactory.create();
    user.setAge("30");
    System.out.println(user.getName());
    System.out.println(user.getAge());
}
```

