## 设计模式-总结
### 关于深拷贝实现方式：		
	1、对象及对象内部所有引用对象都实现Cloneable，然后在实现对象Clone方法时，也要调用内部对象的Clone方法（推荐使用）。	
		Clone方法可使用Java Object本身的Clone方法，也可以自定义实现克隆哪些字段。
	2、通过对象及内部所有引用对象都实现Serilizable接口，然后通过输出、输入流实现序列化和反序列化得到拷贝对象。但这种方式性能很差，不建议使用。	
### 建造者模式的一个典型静态内部类应用示例：		
	public class Computer {	
	 	
	    private String cpu;	
	    private String mainBoard;	
	    private String hardDisk;	
	    private String displayCard;	
	    private String power;	
	    private String memory;	
	 	
	    public Computer(ComputerBuilder computerBuilder){	
	        this.cpu = computerBuilder.cpu;	
	        this.mainBoard = computerBuilder.mainBoard;	
	        this.hardDisk = computerBuilder.hardDisk;	
	        this.displayCard = computerBuilder.displayCard;	
	        this.power = computerBuilder.power;	
	        this.memory = computerBuilder.memory;	
	    }	
	 	
	    @Override	
	    public String toString() {	
	        return "Computer{" +	
	                "cpu='" + cpu + '\'' +	
	                ", mainBoard='" + mainBoard + '\'' +	
	                ", hardDisk='" + hardDisk + '\'' +	
	                ", displayCard='" + displayCard + '\'' +	
	                ", power='" + power + '\'' +	
	                ", memory='" + memory + '\'' +	
	                '}';	
	    }	
	 	
	    public static class ComputerBuilder{	
	 	
	        private String cpu;	
	        private String mainBoard;	
	        private String hardDisk;	
	        private String displayCard;	
	        private String power;	
	        private String memory;	
	 	
	        public ComputerBuilder buildCPU(String cpu){	
	            this.cpu = cpu;	
	            return this;	
	        }	
	        public ComputerBuilder buildMainBoard(String mainBoard){	
	            this.mainBoard = mainBoard;	
	            return this;	
	        }	
	        public ComputerBuilder buildHardDisk(String hardDisk){	
	            this.hardDisk = hardDisk;	
	            return this;	
	        }	
	        public ComputerBuilder buildDisplayCard(String displayCard){	
	            this.displayCard = displayCard;	
	            return this;	
	        }	
	        public ComputerBuilder buildPower(String power){	
	            this.power = power;	
	            return this;	
	        }	
	        public ComputerBuilder buildMemory(String memory){	
	            this.memory = memory;	
	            return this;	
	        }	
	        public Computer build(){	
	            return new Computer(this);	
	        }	
	    }	
	}	
	2，测试类	
	public class Test {	
	    public static void main(String[] args) {	
	        Computer computer = new Computer.ComputerBuilder().buildCPU("酷睿I7").buildMainBoard("华硕主板").build();	
	        System.out.println(computer);	
	        Set<String> set = ImmutableSet.<String>builder().add("a").add("b").build();	
	        System.out.println(set);	
	 	
	    }	
	}	

### 简单工厂模式、工厂方法模式与抽象工厂模式的区别				
	简单工厂模式 （Simple Factory）			
	简单工厂模式的一个典型事例，当用户需要新增产品ProductD时，必须在工厂类的生产方法中增加对应的判断分支，所以简单工厂模式违背了开放封闭原则。			
	首先定义一个产品类的共同接口			
	public interface Product{			
	int price();			
	String getName();			
	}			
	分别有三个产品ProductA、ProductB、ProductC ，均实现Product接口			
	ProductA			
	public class ProductA implements Product {			
	    @Override			
	    public int price() {			
	        return 100;			
	    }			
	    @Override			
	    public String getName() {			
	        return "ProductA";			
	    }			
	}			
	ProductB			
	public class ProductB implements Product {			
	    @Override			
	    public int price() {			
	        return 200;			
	    }			
	    @Override			
	    public String getName() {			
	        return "ProductB";			
	    }			
	}			
	ProductC			
	public class ProductC implements Product {			
	    @Override			
	    public int price() {			
	        return 300;			
	    }			
	    @Override			
	    public String getName() {			
	        return "ProductC";			
	    }			
	}			

定义一个生产工厂类，根据输入类型生产对应的产品				
public class Factory {				
    public static Product createProduct(String type){				
        Product product =null;				
        switch (type){				
            case "A":				
                product = new ProductA();				
                break;				
            case "B":				
                product = new ProductB();				
                break;				
            case "C":				
                product = new ProductC();				
                break;				
        }				
        return product;				
    }				
}				
根据输入的生产类型生产对应的产品				
Product productA = Factory.createProduct("A");				
Product productB = Factory.createProduct("B");				
Product productC = Factory.createProduct("C");				

工厂方法模式 （Factory Method）			
通过工厂方法模式，可以解决简单工厂模式的问题。首先声明一个工厂接口，所有工厂必须实现这个接口。			
首先声明一个工厂接口，所有工厂必须实现这个接口：			
public interface IFactory {			
    Product createProduct();			
}			
生产ProductA的工厂FactoryA：			
public class FactoryA implements IFactory {			
    @Override			
    public Product createProduct() {			
        return new ProductA();			
    }			
}			
生产ProductB的工厂FactoryB：			
public class FactoryB implements IFactory {			
    @Override			
    public Product createProduct() {			
        return new ProductB();			
    }			
}			
同样地，生产ProductC的工厂FactoryC跟以上模式一样。			

现在来根据新的工厂方法模式来生产：				
IFactory factoryA = new FactoryA();				
Product productA = factoryA.createProduct();				
				
IFactory factoryB = new FactoryB();				
Product productB = factoryB.createProduct();				
				
IFactory factoryC = new FactoryB();				
Product productC = factoryC.createProduct();				

当需要增加一个新产品ProductD,只需要新建对应的FactoryD来实现生产功能即可,对原有的代码没有任何影响，非常符合开放封闭原则，	
但是由于每增加一个产品，都需要新增对应的生产工厂，导致增加额外的开发工作量。	
总结：由于使用了多态，工厂方法克服了简单工厂违背的开放封闭原则的缺点，又保持了封装对象创建过程的优点。	
	
抽象工厂模式 (Abstract Factory)	
假设现在需要针对每种产品生产对应的赠品，难道我们要新增一个Gift的生产工厂吗？其实没有必要，因为在这个场景下，每种产品必须附带了赠品，所以我们可以利用原有的工厂来生产赠品。	
先定一个共同的Gift接口：	
public interface Gift {	
    String getGiftName();	
}	
增加GiftA、GiftB、GiftC：	
public class GiftA implements Gift {	
    @Override	
    public String getGiftName() {	
        return "GiftA";	
    }	
}	
修改Factory接口，增加生产Gift的方法：	
public interface IFactory {	
    Product createProduct();	
    Gift createGift();	
}	

修改工厂方法模式下的FactoryA、FactoryB、FactoryC：				
public class FactoryA implements IFactory {				
    @Override				
    public Gift createGift() {				
        return new GiftA();				
    }				
				
    @Override				
    public Product createProduct() {				
        return new ProductA();				
    }				
}				
生产产品和赠品				
IFactory factoryA = new FactoryA();				
Product productA = factoryA.createProduct();				
Gift giftA = factoryA.createGift();				

总结：抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类。抽象工厂接口，应该包含所有的产品创建的抽象方法，我们可以定义实现不止一个接口，
一个工厂也可以生产不止一种产品类，和工厂方法模式一样，抽象工厂模式同样实现了开发封闭原则


