## 泛型
## 泛型定义
我们在编程程序时，经常会遇到功能非常相似的模块，只是它们处理的数据不一样。但我们没有办法，只能分别写多个方法来处理不同的数据类型。这个时候，那么问题来了，有没有一种办法，
用同一个方法来处理传入不同种类型参数的办法呢？泛型的出现就是专门来解决这个问题的，可以看出，微软还是很贴心的。  
### 泛型类型参数
在泛型类型或方法定义中，类型参数是在其实例化泛型类型的一个变量时，客户端指定的特定类型的占位符。 泛型类( GenericList<T>)无法按原样使用，因为它不是真正的类型；它更像是类型的蓝图。 
若要使用 GenericList<T>，客户端代码必须通过指定尖括号内的类型参数来声明并实例化构造类型。 此特定类的类型参数可以是编译器可识别的任何类型。 可创建任意数量的构造类型实例，
其中每个使用不同的类型参数，如下所示：  
```
GenericList<float> list1 = new GenericList<float>();
GenericList<ExampleClass> list2 = new GenericList<ExampleClass>();
GenericList<ExampleStruct> list3 = new GenericList<ExampleStruct>();
```  
在 GenericList<T> 的每个实例中，类中出现的每个 T 在运行时均会被替换为类型参数。 通过这种替换，我们已通过使用单个类定义创建了三个单独的类型安全的有效对象。 
### 泛型约束
定义泛型类时，可以对客户端代码能够在实例化类时用于类型参数的几种类型施加限制。 如果客户端代码尝试使用约束所不允许的类型来实例化类，则会产生编译时错误。 这些限制称为约束。 
通过使用 where 上下文关键字指定约束。 下表列出了六种类型的约束：  
where T:struct  
where T:class  
where T:new()  
where T:基类  
where T:接口名称  
where T:U  
### 泛型方法
我们知道，用object获取是利用了继承这一特性，当编译器编译的时候，我们传入的参数会进行装箱操作，当我们获取的时候又要进行拆箱操作，这个方法会损耗性能 。那么泛型方法实现的原理又是怎样的呢？首先，我们要知道，
泛型是一个语法糖，在我们调用泛型方法，编译器进行编译时，才会确定传入的参数的类型，从而生成副本方法。这个副本方法与原始方法一法，所以不会有装箱拆箱操作，也就没有损耗性能这回事了。
### 泛型类
泛型类封装不特定于特定数据类型的操作。		
通常，创建泛型类是从现有具体类开始，然后每次逐个将类型更改为类型参数，直到泛化和可用性达到最佳平衡。		
创建自己的泛型类时，需要考虑以下重要注意事项：		
**要将哪些类型泛化为类型参数**		
通常，可参数化的类型越多，代码就越灵活、其可重用性就越高。 但过度泛化会造成其他开发人员难以阅读或理解代码。		
**要将何种约束（如有）应用到类型参数**		
其中一个有用的规则是，应用最大程度的约束，同时仍可处理必须处理的类型。 例如，如果知道泛型类仅用于引用类型，则请应用类约束。 这可防止将类意外用于值类型，并使你可在 T 上使用 as 运算符和检查 null 值。　　　　　　			
**是否将泛型行为分解为基类和子类**	
因为泛型类可用作基类，所以非泛型类的相同设计注意事项在此也适用。 请参阅本主题后文有关从泛型基类继承的规则。			
**实现一个泛型接口还是多个泛型接口**
```
class BaseNode { }		
class BaseNodeGeneric<T> { }		
		
// concrete type		
class NodeConcrete<T> : BaseNode { }		
		
//closed constructed type		
class NodeClosed<T> : BaseNodeGeneric<int> { }		
		
//open constructed type 		
class NodeOpen<T> : BaseNodeGeneric<T> { }		
```
### 泛型接口
定义一个泛型接口：							
interface IMyGenericInterface<T>				
{				
}							
一个接口可定义多个类型参数，如下所示：							
interface IMyGenericInterface<TKey,TValue>				
{				
}				
				
具体类可实现封闭式构造接口，如下所示：					
interface IBaseInterface<T> { }						
class SampleClass : IBaseInterface<string> { }//如果T有约束,那么string类型必须得满足T的约束				
### 泛型委托
委托可以定义它自己的类型参数。 引用泛型委托的代码可以指定类型参数以创建封闭式构造类型，就像实例化泛型类或调用泛型方法一样，如以下示例中所示：					
```					
class Program					
{					
    static void Main(string[] args)					
    {					
        Del<int> m1 = new Del<int>(Notify);					
        m1.Invoke(1111);					
        Del<string> m2 = new Del<string>(Notify);					
        m2.Invoke("字符串");					
					
        Console.ReadKey();					
    }					
					
    public delegate void Del<T>(T item);					
    public static void Notify(int i) { Console.WriteLine("{0} type is {1}", i,i.GetType()); }					
    public static void Notify(string str) { Console.WriteLine("{0} type is {1}", str, str.GetType()); }					
       					
}					
```
