## WPF-布局
### StackPanel堆叠布局				
StackPanel是以堆叠的方式显示其中的控件				
1、可以使用Orientation属性更改堆叠的顺序				
Orientation="Vertical"				
默认，由上到下显示各控件。控件在未定义的前提下，宽度为StackPanel的宽度，高度自动适应控件中内容的高度				
Orientation="Horizontal"				
由左到右显示各控件。控件在未定义的前提下，高度为StackPanel的高度，宽度自动适应控件中内容的宽度				
2、设置控件的属性，调整控件的显示				
Margin属性				
定义控件的外边缘，可以通过以下几种方式来设置				
1）Margin=”10”：各边缘均为10				
2）Margin=”10,20,30,40”：设定左、上、右、下各边缘分别为10、20、30、40				
3）使用拆分式方式设定，如上下为10，左右为20				
Width、Height属性				
设定控件的宽度和高度，取消自动的宽度和高度				
HorizontalAlignment、VerticalAlignment属性				
设定控件的水平或竖直对齐方式，如整体Orientation="Vertical"的前提下，设置水平对齐为Left、Right或Center，在没有设定宽度的情况下，控件的宽度自动调整				
MinWidth、MinHeight、MaxWidth、MaxHeight属性				
在调整窗体大小，同时更改控件大小时，控件宽度、高度可变化的最大值和最小值 				
WPF中的StackPanel控件是一种简单常用的布局控件。它可根据orientation属性设置面板里面的每个子元素是依靠在前一个控件的旁边（横向）还是下面（纵向）。				
对于创建各种类型的列表非常有用。所有的继承于ItemsControls的WPF控件，如ComboBox,ListBox和Menu控件都可以使用StackPanel做为它的内部布局面板。				
```				
<StackPanel> 				
<Button Content="按钮"></Button>				
<Button Content="按钮"></Button>				
<Button Content="按钮"></Button>				
<Button Content="按钮"></Button>				
<Label Content="Label"></Label>				
<Label Content="Label"></Label>				
<Label Content="Label"></Label>				
</StackPanel> 				

<Window x:Class="WpfApplication1.MainWindow" 		
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 		
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 		
Title="MainWindow"> 		
<StackPanel Orientation="Horizontal"> 		
<Button Content="按钮"></Button>		
<Button Content="按钮"></Button>		
<Button Content="按钮"></Button>		
<Button Content="按钮"></Button>		
<Label Content="Label"></Label>		
<Label Content="Label"></Label>		
<Label Content="Label"></Label>		
</StackPanel> 		
</Window>		
```
### WrapPanel包裹布局		
以流的形式由左到右，由上到下显示控件，其功能类似于Java AWT布局中的FlowLayout		
在WrapPanel面板中的元素以一次一行或一列的方式布局控件		
WrapPanel也有Orientation属性，但与StackPanel不同的是，WrapPanel的Orientation属性的默认值是Horizontal		
也就是说WrapPanel的默认展现方向是横向的		
WrapPanel与StackPanel另一个不同的地方是，当容器实际宽度不够的情况下，内容将以多行或者多列的形式展现	
```
<WrapPanel>		
<Button Content="allen"></Button>		
<Button Content="allen"></Button>		
<Button Content="allen"></Button>		
<Button Content="allen"></Button>		
<Button Content="allen"></Button>		
<Button Content="allen"></Button>		
</WrapPanel>		

<WrapPanel Orientation="Vertical">				
<Button Content="allen1"></Button>				
<Button Content="allen2"></Button>				
<Button Content="allen3"></Button>				
<Button Content="allen4"></Button>				
<Button Content="allen5"></Button>				
<Button Content="allen6"></Button>				
<Button Content="allen7"></Button>				
<Button Content="allen8"></Button>				
<Button Content="allen9"></Button>				
<Button Content="allen10"></Button>				
</WrapPanel>				
```
### DockPanel停靠布局						
以上、下、左、右、中为基本结构的布局方式，类似于Java AWT布局中的BorderLayout。						
但与BorderLayout不同的是，每一个区域可以同时放置多个控件，在同一区域放置的多个控件采用的布局方式为StackPanel方式。						
						
WPF 主界面布局中DockPanel的停靠与默认填充						
						
在WPF中，通常的主界面大都是DockPanel 根元素，一次DockPanel .Top主菜单、DockPanel .Top Toolbar、DockPanel .Bottom Statusbar，中建Fill一个主区域，						
但在使用时往往有个误区，就是充满剩余空间的元素如何填充，因为DockPanel没有DockPanel.Fill属性。实际做法是先停靠Menu、Toolbar、Statusbar等等可以通过DockPanel .Top、						
DockPanel .Bottom、DockPanel .Left、DockPanel .Right停靠的子元素，然后，也就是最后，加入填充区元素，同时注意，不能设置此元素的DockPanel属性，这样，						
最后加入的元素就自动填充整个剩余空间了。						
　　文档中对这一"技巧"没有任何说明，导致无谓的时间浪费，记录于此，希望对大家有所帮助。						
如果“Dockstyle.Dock”属性设置为 Top 或 Bottom，请将控件的“Width”属性设置为 Auto。同样，如果“Dockstyle.Dock”属性设置为 Left 或 Right，						
请将控件的“Height”属性设置为 Auto。						
　　默认情况下 DockPanel 设置为 LastChildFill，这表示添加到 DockPanel 的最后一个子控件将使其 DockPanel.Dock 属性设置为 Fill。						
若要更改此行为，请设置 DockPanel 的 LastChildFill 属性。
```
<DockPanel>						
<!--沿着上边缘拉伸-->						
<Button Content="Top" DockPanel.Dock="Top"></Button>						
<!--沿着下边缘拉伸-->						
<Button Content="Bottom" DockPanel.Dock="Bottom"></Button>						
<!--沿着左边缘拉伸-->						
<Button Content="Left" DockPanel.Dock="Left"></Button>						
<!--沿着右边缘拉伸-->						
<Button Content="Right" DockPanel.Dock="Right"></Button>						
<!--默认沿着左边缘拉伸-->						
<Button Content="allen5"></Button>						
<!--默认沿着左边缘拉伸-->						
<Button Content="allen6"></Button>						
<!--最后一个元素默认填充满整个容器剩余的空间-->						
<Button Content="默认最后一个自适应"></Button>						
</DockPanel>						
```
### Grid表格布局										
Grid布局容器可以把空间分割成多行多列，用以摆放不同的控件										
Grid和其他各个Panel比较起来，功能最多也最为复杂。要使用Grid，首先要向RowDefinitions和ColumnDefinitions属性中添加一定数量的RowDefinitions和 ColumnDefinitions元素，										
从而定义行数和列数。而放置在Grid面板中的控件元素都必须显示采用附加属性语法定义其 放置所在的行和列，它们都是以0为基准的整型 值，如果没有显式设置任何行或列，										
Grid将会隐式地将控件加入在第0行第0列。由于Grid的组成并非简单的添加属性标记来区分行列，这也使得用户在实际应用中可以具体到某一单 元格中，所以布局起来就很精细了。 										
Grid的单元格可以是空的，一个单元格中可以有多个元素，而在单元格中元素是根据它们的Z顺序一个接着一个呈现的。与Canvas一样，										
同一个单元格中 的子元素不会与其他元素交互布局，信息——它们仅仅是重叠而已。										
使用Grid.ColumnSpan和Grid.RowSpan附加属性可以让相互间隔的行列合并，所以元素也可以跨越多个单元格。 										
使用GridSplit分割	
```
<GridSplitter Height="6" VerticalAlignment="Stretch" HorizontalAlignment="Stretch" 										
               Grid.Row="2" Grid.Column="2"></GridSplitter>		
```               
使用GridSplit控件结合Grid控件实现类似于WinForm中SplitContainer的功能，这个大家在WinForm当中经常用到，我们也不多做介绍。										
```
<Grid>										
<!--定义两行-->										
<Grid.RowDefinitions>										
<RowDefinition></RowDefinition>										
<RowDefinition></RowDefinition>										
</Grid.RowDefinitions>										
<!--定义三列-->										
<Grid.ColumnDefinitions>										
<ColumnDefinition></ColumnDefinition>										
<ColumnDefinition></ColumnDefinition>										
<ColumnDefinition></ColumnDefinition>										
</Grid.ColumnDefinitions>										
<!--Grid.Row或 Grid.Column的默认值为0-->										
<Button Content="默认在第一行第一列且填充"></Button>										
<!--如果我把Grid.Row的值设置成2，因为没有第三行，所以按钮会自动被放在最后一行，仍然是第二行-->										
<Button Grid.Row="1" Grid.Column="1" Content="第二行第二列"></Button>										
</Grid>										
```
### Canvas画布布局				
Canvas画布布局容器允许使用精确的坐标来摆放画布内的元素				
如果两个元素共用了同一块区域，那么后设置的元素将覆盖先设置的元素	
```
<Canvas>				
<Button Canvas.Left="100" Canvas.Top="100" Content="第一个按钮"></Button>				
<Button Canvas.Left="136" Canvas.Top="112" Content="第二个按钮"></Button>				
</Canvas>				
```
### UniformGrid				
是一种横向的网格分割、纵向的网格分割分别是均等的分割的布局类型，故称为 " 均分布局 "。				
UniformGrid 就是Grid的简化版，每个单元格的大小相同，不需要定义行列集合。每个单元格始终具有相同的大小，每个单元格只能容纳一个控件，				
将自动按照定义在其内部的元素个数，自动创建行列，并通常保持相同的行列数。UniformGrid 中没有Row 和Column 附加属性，也没有空白单元格。				
与Grid布局控件相比，UniformGrid布局控件很少使用。Grid面板是用于创建简单乃至复杂窗口布局的通用工具。UniformGrid面板是一个一种更特殊的布局容器，主要用于在一个刻板的网格中快速地布局元素。				
对于 Grid 的属性 Grid.Row 、Grid.Column 和 Grid.RowSpan 、Grid.ColumnSpan 用在 UniformGrid 上会没有任何的效果（虽然可以写上去，因为是附加属性）				
```
<UniformGrid Columns="2" Rows="3">				
    <Rectangle Fill="Aqua"/>				
    <Rectangle Fill="Red"/>				
    <Rectangle Fill="Red"/>				
    <Rectangle Fill="Aqua"/>				
    <Rectangle Fill="Aqua"/>				
    <Rectangle Fill="Red"/>				
</UniformGrid>				
```
### Window窗口						
窗口是容纳所有WPF界面元素的最初容器，任何的界面元素都要放在Window窗口内才能呈现						
WPF窗口只能包含一个儿子控件，这是因为Window类继承自ContentControl类。						
ContentControl就是我们常说的内容控件，这种控件与容器控件（Grid或StackPanel）不同，						
内容控件的顶级子元素只能有一个，容器控件可以包含多个顶级子元素						
如果我们想要在一个ContentControl内展示多个子控件，						
我们可以先放置一个容器控件作为内容控件的顶级子元素，然后再在此容器控件中放置更多的控件
```
<Window x:Class="WpfApplication1.MainWindow" 						
xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" 						
xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 						
Title="MainWindow" Height="350" Width="525"> 						
<Grid>						
<Button Content="Button" />						
<Button Content="Button" />						
</Grid>						
</Window>						
```	


