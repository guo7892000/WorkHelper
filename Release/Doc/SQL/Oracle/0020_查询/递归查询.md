### 递归
所谓递归,简单点来说,就是一个函数直接或间接调用自身的一种方法,它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。
#### 递归查询
```
/*递归查询*/
SELECT employee_id, name, manager_id, LEVEL
FROM employees
START WITH manager_id IS NULL -- 从最高层开始
CONNECT BY PRIOR employee_id = manager_id; -- 指定父子关系

/*Oracle 11g及更高版本中可用的递归查询*/
WITH RECURSIVE employee_cte (employee_id, name, manager_id, level) AS (
SELECT employee_id, name, manager_id, 1 AS level -- 非递归部分（基线条件）
FROM employees
WHERE manager_id IS NULL -- 起始点
UNION ALL
SELECT e.employee_id, e.name, e.manager_id, ec.level + 1 -- 递归部分
FROM employees e
INNER JOIN employee_cte ec ON e.manager_id = ec.employee_id -- 连接条件
)
SELECT * FROM employee_cte;  
```
#### sys_connect_by_path函数
sys_connect_by_path(字段名, 连接符)：是oracle9i新提出来的，用来显示分层查询的路径，从跟节点到子节点的路径。 注意：sys_connect_by_path()函数必须和connect by 关键字一起使用。
```
/*示例1*/
With tb As
     (Select *
        From t_assembly_spec t
       Where t.oper_id = #{userId,jdbcType=VARCHAR}
         And t.assembly_code = #{itemId,jdbcType=VARCHAR})
    Select a.spec_class As "pid",
           a.spec_class_name As "pname",
           a.spec_code As "id",
           a.spec_code_name As "cname",
           SYS_CONNECT_BY_PATH(a.spec_code, '/') As "path",
           (Select Count(*) From tb s Where s.spec_class = a.spec_code) As "child_count"
      From tb A
     Start With a.spec_class Is Null
    Connect By a.spec_class = Prior a.spec_code
     Order Siblings By a.spec_class, a.spec_code
;

/*示例2*/
/*首先数据库中的字段：empno--empname--mgr;从'King'开始,把'King'的编号做为管理编号，然后在'King'编号为管理员的员工就是他的下属（循环方式）。*/
--CREAT TABLE emp
create table emp ( empno varchar2(5), ename varchar2(8), mgr varchar2(8));
--INSERT DATA
insert into emp (EMPNO, ENAME, MGR) values ('1', 'jim', '7');
insert into emp (EMPNO, ENAME, MGR) values ('2', 'tom', '7');
insert into emp (EMPNO, ENAME, MGR) values ('3', 'tim', '7');
insert into emp (EMPNO, ENAME, MGR) values ('4', 'lily', '7');
insert into emp (EMPNO, ENAME, MGR) values ('5', 'mary', '7');
insert into emp (EMPNO, ENAME, MGR) values ('6', 'tid', '7');
insert into emp (EMPNO, ENAME, MGR) values ('7', 'King', '10');
insert into emp (EMPNO, ENAME, MGR) values ('8', 'kenvin', '10');
insert into emp (EMPNO, ENAME, MGR) values ('9', 'shema', '8');
insert into emp (EMPNO, ENAME, MGR) values ('10', 'john', '0');
insert into emp (EMPNO, ENAME, MGR) values ('0', 'root', '');

-- 可以理解为查询king的所有下属
select sys_connect_by_path(ename,'>') tree from emp start with ename='King' connect by prior empno = mgr;

--可以理解为查询king的领导 效果与connect by prior mgr= empno相同
select sys_connect_by_path(ename,'/') tree from emp start with ename='King' connect by empno= prior mgr; 
--可以理解为查询king的领导
select sys_connect_by_path(ename,'/') tree,level from emp start with ename='King' connect by prior mgr= empno;
--总结：connect by prior column1 = column2 或者 connect by  column2 = prior column1 写法都可以，
主要看prior写在谁的前面，prior（先前的）写在谁的前面谁就作为父级值（参照值），也就是说[connect by prior column1 = column2]的意思就是是 按start with 条件查询出的记录行，以column1为参考值，查询column2为column1值的记录


```
