## DBMS_JOB和JOB区别
Oralce中的任务有2种：Job和Dbms_job，两者的区别有：  
1． jobs是oracle数据库的对象， dbms_jobs只是jobs对象的一个实例， 就像对于tables， emp和dept都是表的实例。  
2． 创建方式也有差异，Job是通过调用dbms_scheduler.create_job包创建的，Dbms_job则是通过调用dbms_job.submit包创建的。  
3． 两种任务的查询视图都分为dba和普通用户的，Job对应的查询视图是dba_scheduler_jobs和user_scheduler_jobs，
dbms_jobs对应的查询视图为dba_jobs和user_jobs。 
### DBMS_JOB：传统定时任务方案
DBMS_JOB是Oracle早期版本提供的定时任务工具，适用于11g及更早版本。其核心流程包括存储过程创建、任务提交和生命周期管理三个阶段。  
```
CREATE OR REPLACE PROCEDURE my_job_proc AS
BEGIN
  -- 示例：向日志表插入执行记录
  INSERT INTO job_log VALUES (SYSDATE, 'DBMS_JOB executed');
  COMMIT;
END;
/

/*任务提交与调度*/
DECLARE
  jobno NUMBER;
BEGIN
  DBMS_JOB.SUBMIT(
    job => jobno,
    what => 'my_job_proc;',
    next_date => SYSDATE,  -- 立即执行
    interval => 'SYSDATE + 1/24'  -- 每小时执行
  );
  COMMIT;
  DBMS_OUTPUT.PUT_LINE('Job ID: ' || jobno);
END;
/

```
### DBMS_SCHEDULER：增强型调度方案
Oracle 10g引入的DBMS_SCHEDULER提供了更强大的调度能力，支持日历表达式、任务依赖等高级功能。  
高级调度语法  
调度需求	表达式示例  
每日8点执行	FREQ=DAILY; BYHOUR=8  
每周一执行	FREQ=WEEKLY; BYDAY=MON  
每月最后一天	FREQ=MONTHLY; BYMONTHDAY=-1   
```
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name => 'MY_SCHEDULER_JOB',
    job_type => 'PLSQL_BLOCK',
    job_action => 'BEGIN my_scheduler_proc; END;',
    start_date => SYSTIMESTAMP,
    repeat_interval => 'FREQ=HOURLY; INTERVAL=1',
    enabled => TRUE
  );
END;
/

-- 创建带参数的任务
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name => 'PARAM_JOB',
    job_type => 'STORED_PROCEDURE',
    job_action => 'PROCESS_DATA',
    number_of_arguments => 1,
    start_date => SYSTIMESTAMP,
    repeat_interval => 'FREQ=DAILY',
    enabled => FALSE
  );
  
  -- 设置参数
  DBMS_SCHEDULER.SET_JOB_ARGUMENT_VALUE(
    job_name => 'PARAM_JOB',
    argument_position => 1,
    argument_value => 'INPUT_DATA'
  );
  
  -- 启用任务
  DBMS_SCHEDULER.ENABLE('PARAM_JOB');
END;
/

```
### 关键参数对比
参数维度	DBMS_JOB	DBMS_SCHEDULER
时间精度	分钟级	秒级
调度表达式	简单间隔	日历语法
任务依赖	不支持	支持
优先级控制	不支持	支持
日志记录	基础	详细执行日志

### 最佳实践建议
版本适配：12c及以上版本优先使用DBMS_SCHEDULER
复杂调度：需要日历表达式时必须使用DBMS_SCHEDULER
权限管理：确保执行用户具有CREATE JOB权限
监控机制：定期查询USER_SCHEDULER_JOB_RUN_DETAILS检查执行状态

### 完整案例：每日数据汇总
```
-- 1. 创建结果表
CREATE TABLE daily_summary (
  summary_date DATE,
  record_count NUMBER
);

-- 2. 创建汇总过程
CREATE OR REPLACE PROCEDURE daily_aggregate AS
  v_count NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_count FROM transaction_logs 
  WHERE trunc(log_time) = trunc(SYSDATE);
  
  INSERT INTO daily_summary VALUES (TRUNC(SYSDATE), v_count);
  COMMIT;
END;
/

-- 3. 创建每日凌晨执行的任务
BEGIN
  DBMS_SCHEDULER.CREATE_JOB(
    job_name => 'DAILY_AGG_JOB',
    job_type => 'STORED_PROCEDURE',
    job_action => 'daily_aggregate',
    start_date => TRUNC(SYSTIMESTAMP) + INTERVAL '1' DAY,
    repeat_interval => 'FREQ=DAILY; BYHOUR=2',
    enabled => TRUE,
    comments => 'Daily transaction summary'
  );
END;
/
```
