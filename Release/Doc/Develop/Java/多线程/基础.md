## Java多线程-基础
### Java线程的通信方式	
**线程之间为什么要通信？**  
通信的目的是为了更好的协作，线程无论是交替式执行，还是接力式执行，都需要进行通信告知。那么java线程是如何通信的呢，大致有以下四种方式。  
1. volatile  
2. 等待/通知机制  
3. join方式  
4. threadLocal  
	
**volatile关键字**  
volatile有两大特性，一是可见性，二是有序性，禁止指令重排序，其中可见性就是可以让线程之间进行通信。  
volatile语义保证线程可见性有两个原则保证  
所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存  
所有volatile修饰的变量在使用之前必须重新读取主内存的值  
如果将volatile关键字去掉，线程切换一定次数后将不能感知到flag的变化，最开始能感知是线程启动时间差的原因。  
	
**等待/通知机制**  
等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。  
为什么要必须获取锁？  
因为调用wait方法时，必须要先释放锁，如果没有持有锁将会抛出异常。  
	
**join方式**  
join其实合理理解成是线程合并，当在一个线程调用另一个线程的join方法时，当前线程阻塞等待被调用join方法的线程执行完毕才能继续执行，
所以join的好处能够保证线程的执行顺序，但是如果调用线程的join方法其实已经失去了并行的意义，虽然存在多个线程，
但是本质上还是串行的，最后join的实现其实是基于等待通知机制的。  
	
**threadLocal方式**  
threadLocal方式的线程通信，不像以上三种方式是多个线程之间的通信，它更像是一个线程内部的通信，将当前线程和一个map绑定，
在当前线程内可以任意存取数据，减省了方法调用间参数的传递。  

### Executor VS  ExecutorService VS Executors			
正如上面所说，这三者均是 Executor 框架中的一部分。Java 开发者很有必要学习和理解他们，以便更高效的使用 Java 提供的不同类型的线程池。
总结一下这三者间的区别，以便大家更好的理解：		
Executor 和 ExecutorService 这两个接口主要的区别是：ExecutorService 接口继承了 Executor 接口，是 Executor 的子接口		
Executor 和 ExecutorService 第二个区别是：Executor 接口定义了 execute()方法用来接收一个Runnable接口的对象，
	而 ExecutorService 接口中的 submit()方法可以接受Runnable和Callable接口的对象。		
Executor 和 ExecutorService 接口第三个区别是 Executor 中的 execute() 方法不返回任何结果，而 ExecutorService 中的 submit()方法
	可以通过一个 Future 对象返回运算结果。		
Executor 和 ExecutorService 接口第四个区别是除了允许客户端提交一个任务，ExecutorService 还提供用来控制线程池的方法。
	比如：调用 shutDown() 方法终止线程池。		
			
Executors 类提供工厂方法用来创建不同类型的线程池。比如: newSingleThreadExecutor() 创建一个只有一个线程的线程池，
newFixedThreadPool(int numOfThreads)来创建固定线程数的线程池，		
newCachedThreadPool()可以根据需要创建新的线程，但如果已有线程是空闲的会重用已有线程。	

### java线程池ThreadPoolExecutor类使用详解											
在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；										
另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、										
newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，										
使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险。    										
```
	public ThreadPoolExecutor(int corePoolSize,										
	                            int maximumPoolSize,										
	                            long keepAliveTime,										
	                            TimeUnit unit,										
	                            BlockingQueue<Runnable> workQueue,										
	                            ThreadFactory threadFactory,										
	                            RejectedExecutionHandler handler) {										
	    if (corePoolSize < 0 ||										
	        maximumPoolSize <= 0 ||										
	        maximumPoolSize < corePoolSize ||										
	        keepAliveTime < 0)										
	        throw new IllegalArgumentException();										
	    if (workQueue == null || threadFactory == null || handler == null)										
	        throw new NullPointerException();										
	    this.acc = System.getSecurityManager() == null ?										
	            null :										
	            AccessController.getContext();										
	    this.corePoolSize = corePoolSize;										
	    this.maximumPoolSize = maximumPoolSize;										
	    this.workQueue = workQueue;										
	    this.keepAliveTime = unit.toNanos(keepAliveTime);										
	    this.threadFactory = threadFactory;										
	    this.handler = handler;										
	}	
```	
构造函数的参数含义如下：  
```
corePoolSize:指定了线程池中的线程数量，它的数量决定了添加的任务是开辟新的线程去执行，还是放到workQueue任务队列中去；										
maximumPoolSize:指定了线程池中的最大线程数量，这个参数会根据你使用的workQueue任务队列的类型，决定线程池会开辟的最大线程数量；										
keepAliveTime:当线程池中空闲线程数量超过corePoolSize时，多余的线程会在多长时间内被销毁；										
unit:keepAliveTime的单位										
workQueue:任务队列，被添加到线程池中，但尚未被执行的任务；它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列几种；										
threadFactory:线程工厂，用于创建线程，一般用默认即可；										
handler:拒绝策略；当任务太多来不及处理时，如何拒绝任务；										
```											
**一、workQueue任务队列**  									
上面我们已经介绍过了，它一般分为直接提交队列、有界任务队列、无界任务队列、优先任务队列；										
1、直接提交队列：设置为SynchronousQueue队列，SynchronousQueue是一个特殊的BlockingQueue，它没有容量，没执行一个插入操作就会阻塞，需要再执行一个删除操作才会被唤醒，反之每一个删除操作也都要等待对应的插入操作。										
	//maximumPoolSize设置为2 ，拒绝策略为AbortPolic策略，直接抛出异常									
	pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new SynchronousQueue<Runnable>(),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());									
可以看到，当任务队列为SynchronousQueue，创建的线程数大于maximumPoolSize时，直接执行了拒绝策略抛出异常。										
使用SynchronousQueue队列，提交的任务不会被保存，总是会马上提交执行。如果用于执行任务的线程数量小于maximumPoolSize，则尝试创建新的进程，如果达到maximumPoolSize设置的最大值，										
则根据你设置的handler执行拒绝策略。因此这种方式你提交的任务不会被缓存起来，而是会被马上执行，在这种情况下，你需要对你程序的并发量有个准确的评估，才能设置合适的maximumPoolSize数量，否则很容易就会执行拒绝策略；										
2、有界的任务队列：有界的任务队列可以使用ArrayBlockingQueue实现										
	pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(10),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());									
使用ArrayBlockingQueue有界任务队列，若有新的任务需要执行时，线程池会创建新的线程，直到创建的线程数量达到corePoolSize时，则会将新的任务加入到等待队列中。若等待队列已满，即超过ArrayBlockingQueue初始化的容量，										
则继续创建线程，直到线程数量达到maximumPoolSize设置的最大线程数量，若大于maximumPoolSize，则执行拒绝策略。在这种情况下，线程数量的上限与有界任务队列的状态有直接关系，如果有界队列初始容量较大或者没有达到超负荷的状态，										
线程数将一直维持在corePoolSize以下，反之当任务队列已满时，则会以maximumPoolSize为最大线程数上限。										
3、无界的任务队列：有界任务队列可以使用LinkedBlockingQueue实现										
	pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());									
使用无界任务队列，线程池的任务队列可以无限制的添加新的任务，而线程池创建的最大线程数量就是你corePoolSize设置的数量，也就是说在这种情况下maximumPoolSize这个参数是无效的，										
哪怕你的任务队列中缓存了很多未执行的任务，当线程池的线程数达到corePoolSize后，就不会再增加了；若后续有新的任务加入，则直接进入队列等待，当使用这种任务队列模式时，一定要注意你任务提交与处理之间的协调与控制，										
不然会出现队列中的任务由于无法及时处理导致一直增长，直到最后资源耗尽的问题。										
4、优先任务队列：优先任务队列通过PriorityBlockingQueue实现										
	pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new PriorityBlockingQueue<Runnable>(),Executors.defaultThreadFactory(),new ThreadPoolExecutor.AbortPolicy());									
大家可以看到除了第一个任务直接创建线程执行外，其他的任务都被放入了优先任务队列，按优先级进行了重新排列执行，且线程池的线程数一直为corePoolSize，也就是只有一个。										
通过运行的代码我们可以看出PriorityBlockingQueue它其实是一个特殊的无界队列，它其中无论添加了多少个任务，线程池创建的线程数也不会超过corePoolSize的数量，只不过其他队列一般是按照先进先出的规则处理任务，										
而PriorityBlockingQueue队列可以自定义规则根据任务的优先级顺序先后执行。										
											
**二、拒绝策略**										
一般我们创建线程池时，为防止资源被耗尽，任务队列都会选择创建有界任务队列，但种模式下如果出现任务队列已满且线程池创建的线程数达到你设置的最大线程数时，这时就需要你指定ThreadPoolExecutor的RejectedExecutionHandler参数即合理的拒绝策略，										
来处理线程池"超载"的情况。ThreadPoolExecutor自带的拒绝策略如下：										
1、AbortPolicy策略：该策略会直接抛出异常，阻止系统正常工作；										
2、CallerRunsPolicy策略：如果线程池的线程数量达到上限，该策略会把任务队列中的任务放在调用者线程当中运行；										
3、DiscardOledestPolicy策略：该策略会丢弃任务队列中最老的一个任务，也就是当前任务队列中最先被添加进去的，马上要被执行的那个任务，并尝试再次提交；										
4、DiscardPolicy策略：该策略会默默丢弃无法处理的任务，不予任何处理。当然使用此策略，业务场景中需允许任务的丢失；										
以上内置的策略均实现了RejectedExecutionHandler接口，当然你也可以自己扩展RejectedExecutionHandler接口，定义自己的拒绝策略:  
```
//自定义拒绝策略									
	pool = new ThreadPoolExecutor(1, 2, 1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(5),										
	        Executors.defaultThreadFactory(), new RejectedExecutionHandler() {										
	    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {										
	        System.out.println(r.toString()+"执行了拒绝策略");										
	                										
	    }										
	});										
```											
可以看到由于任务加了休眠阻塞，执行需要花费一定时间，导致会有一定的任务被丢弃，从而执行自定义的拒绝策略；										
三、ThreadFactory自定义线程创建										
	 线程池中线程就是通过ThreadPoolExecutor中的ThreadFactory，线程工厂创建的。那么通过自定义ThreadFactory，可以按需要对线程池中创建的线程进行一些特殊的设置，如命名、优先级等，										
下面代码我们通过ThreadFactory对线程池中创建的线程进行记录与命名	:  
```
	    //自定义线程工厂										
	    pool = new ThreadPoolExecutor(2, 4, 1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(5),										
	            new ThreadFactory() {										
	        public Thread newThread(Runnable r) {										
	            System.out.println("线程"+r.hashCode()+"创建");										
	            //线程命名										
	            Thread th = new Thread(r,"threadPool"+r.hashCode());										
	            return th;										
	        }										
	    }, new ThreadPoolExecutor.CallerRunsPolicy());	
```  		
可以看到线程池中，每个线程的创建我们都进行了记录输出与命名。										
**四、ThreadPoolExecutor扩展**  										
ThreadPoolExecutor扩展主要是围绕beforeExecute()、afterExecute()和terminated()三个接口实现的，										
1、beforeExecute：线程池中任务运行前执行										
2、afterExecute：线程池中任务运行完毕后执行										
3、terminated：线程池退出后执行										
通过这三个接口我们可以监控每个任务的开始和结束时间，或者其他一些功能。										
	//实现自定义接口									
	    pool = new ThreadPoolExecutor(2, 4, 1000, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(5),										
	            new ThreadFactory() {										
	        public Thread newThread(Runnable r) {										
	            System.out.println("线程"+r.hashCode()+"创建");										
	            //线程命名										
	            Thread th = new Thread(r,"threadPool"+r.hashCode());										
	            return th;										
	        }										
	    }, new ThreadPoolExecutor.CallerRunsPolicy()) {										
	    										
	        protected void beforeExecute(Thread t,Runnable r) {										
	            System.out.println("准备执行："+ ((ThreadTask)r).getTaskName());										
	        }										
	            										
	        protected void afterExecute(Runnable r,Throwable t) {										
	            System.out.println("执行完毕："+((ThreadTask)r).getTaskName());										
	        }										
	            										
	        protected void terminated() {										
	            System.out.println("线程池退出");										
	        }										
	    };										
可以看到通过对beforeExecute()、afterExecute()和terminated()的实现，我们对线程池中线程的运行状态进行了监控，在其执行前后输出了相关打印信息。另外使用shutdown方法可以比较安全的关闭线程池， 										
当线程池调用该方法后，线程池中不再接受后续添加的任务。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出。										
											
**五、线程池线程数量**										
线程吃线程数量的设置没有一个明确的指标，根据实际情况，只要不是设置的偏大和偏小都问题不大，结合下面这个公式即可										
	        /**										
	            * Nthreads=CPU数量										
	            * Ucpu=目标CPU的使用率，0<=Ucpu<=1										
	            * W/C=任务等待时间与任务计算时间的比率										
	            */										
	        Nthreads = Ncpu*Ucpu*(1+W/C)										

### 线程安全总结：	
	StringBuffer是线程安全，而StringBuilder是线程不安全的。
	java.util.concurrent.*下包含Blocking,CopyOnWrite,Concurrent都是线程安全集合。
**1、JUC概述**
	线程安全性：  
	原子性（互斥访问）、可见性（一个线程对主内存修改其他线程能观察到）、有序性（volatile禁止指令重排）。  	
	Compare and Swap（CAS）：
	AbstractQueuedSynchronizer（AQS）:抽象队列同步器，是一种锁机制。它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。
	原理：AQS就是基于CLH队列（虚拟的双向队列），用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。
	实现了AQS的锁有：ReentrantLock(独占)，Semaphore(共享)，CountDownLatch(共享)，CyclicBarrier(共享)，ReentrantReadWriteLock(独占写共享读)都是AQS的衍生物。
	
	进程和线程。Synchronized。
	新建状态(New)，就绪状态(Runnable)，运行状态(Running)，阻塞状态(Blocked)，死亡状态(Dead)
	当线程调用了自身的sleep()方法或其他线程的join()方法，进程让出CPU，然后就会进入阻塞状态（该状态既停止当前线程，但并不释放所占有的资源即调用sleep ()函数后，线程不会释放它的“锁标志”。）。
	线程调用了yield()方法，意思是放弃当前获得的CPU时间片，回到就绪状态，这时与其他进程处于同等竞争状态，OS有可能会接着又让这个进程进入运行状态。
	wait()和 notify() 方法：当线程调用wait()方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同），进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()
	    或notifyAll()方法才能被唤醒（由于notify()只是唤醒一个线程，但我们由不能确定具体唤醒的是哪一个线程，也许我们需要唤醒的线程不能够被唤醒，因此在实际使用时，一般都用notifyAll()方法，
	    唤醒有所线程），线程被唤醒后会进入锁池，等待获取锁标记。wait() 和 notify() 方法这一对却直接隶属于 Object 类。
**2、Lock接口**  
	`Lock lock = new ReentrantLock();`  
**3、线程间通信**
	虚假唤醒：使用while代替if  
	`wait,notify,notifyAll,join`
**4、线程间定制化通信**
```
	private Lock lock = new ReentrantLock();
	private Condition c1 = lock.newCondition();
	private Condition c2 = lock.newCondition();
	c1.await();
	c2.signal();
```
**5、集合的线程安全**
```
	List<String> list = new CopyOnWriteArrayList();//常用，并发读，独立写
	Set<String> set = new CopyOnWriteArraySet();//无序，不重复。常用，并发读，独立写。
	Map<String,String> map = new ConcurrentHashMap<String,String>();//常用
```
**6、多线程锁**
	静态方法是以类为锁（只且只有一把）；不同实例对象是不同锁。
	公平锁与非公平锁（常用）。
	可重入锁也叫递归锁，注意加锁解锁一一对应。
	死锁
**7、Callable接口**
```
	FutureTask<Integer> futureTask = new FutureTask<>(new ThreadCallable());//使用实现Callable接口的类
	FutureTask<Integer> futureTask2 = new FutureTask<>(()->{
	    return  300;
	});
	new Thread(futureTask,"T1").start();
	new Thread(futureTask2,"T1").start();
	System.out.println(String.valueOf(futureTask.get() + futureTask2.get()));//最后只需要汇总一次
```
**8、JUC强大的辅助类**
```
	CountDownLatch countDownLatch = new CountDownLatch(6);//初始值
	countDownLatch.countDown();//不同线程中调用
	countDownLatch.await();//减数记数，等到计数为0才往后执行
	
	//循环屏障：等所有任务完成后执行一个回调
	CyclicBarrier cyclicBarrier = new CyclicBarrier(num,()->{
	    System.out.println("已集齐7颗龙珠，成功召唤神龙!");
	});
	cyclicBarrier.await();//不同线程中调用
	
	Semaphore semaphore = new Semaphore(3);//信号灯，固定的资源轮流用
	semaphore.acquire();//不同线程中调用
	semaphore.release();//不同线程中调用
```	
**9、ReentrantReadWriteLock读写锁**
```
	ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
	ReentrantReadWriteLock.ReadLock rLock = rwLock.readLock();
	ReentrantReadWriteLock.WriteLock wLock  = rwLock.writeLock();
```
**10、BlockingQueue阻塞队列**
	new ArrayBlockingQueue<>(3);
	
**11、ThreadPool线程池**
```
	ExecutorService poolExecute = new ThreadPoolExecutor(2, 5, 60L, TimeUnit.SECONDS,
	new ArrayBlockingQueue<>(3),
	Executors.defaultThreadFactory(),
	new ThreadPoolExecutor.AbortPolicy()
	);
```
**12、Fork/Join分支合并框架**
```
	public class MyTask extends RecursiveTask<Integer> {
	@Override
	protected Integer compute() {
	
	MyTask myTask = new MyTask(1,1000);
	ForkJoinPool forkJoinPool = new ForkJoinPool();//特殊的线程池
	ForkJoinTask<Integer> forkJoinTask = forkJoinPool.submit(myTask);
	Integer result = forkJoinTask.get();//通过get方法得到计算结果
```
**13、CompletableFuture异步回调**
```
CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(()->{
System.out.println("CompletableFuture.runAsync:Void");
});
completableFuture.get();
	
CompletableFuture<String> completableFuture2 = CompletableFuture.supplyAsync(()->{
	    System.out.println("CompletableFuture.supplyAsync:String");
	    return "supplyAsync.String";
	});
```	
**14、 atomic**
AtomicBoolean 
new AtomicInteger(0).incrementAndGet();//AtomicInteger、AtomicLong
new AtomicLong(0).getAndIncrement();//AtomicInteger、AtomicLong
AtomicIntegerArray
AtomicIntegerFieldUpdater：用于更新某个实例对象中，被valatile修饰的非静态的类型为int的属性值！
AtomicLongArray
AtomicLongFieldUpdater
AtomicMarkableReference
AtomicReference
AtomicReferenceArray
AtomicReferenceFieldUpdater
AtomicStampedReference：解决ABA问题
DoubleAccumulator
DoubleAdder
LongAccumulator
LongAdder类与AtomicLong类的区别在于高并发时前者将对单一变量的CAS操作分散为对数组cells中多个元素的CAS操作，取值时进行求和；而在并发较低时仅对base变量进行CAS操作，与AtomicLong类原理相同。
new LongAdder().increment();
