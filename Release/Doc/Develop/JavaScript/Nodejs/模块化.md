## Nodejs-模块化
### 模块化
Node 采用的模块化结构是按照 CommonJS 规范，模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。					
node_modules：该目录为模块清单。					
dist：为程序生成目录					
					
一、先了解一下，nodejs中require的加载机制					
1、require的加载文件顺序					
require 加载文件时可以省略扩展名：					
          require('./module'); 					
					
     // 此时文件按 JS 文件执行					
          require('./module.js'); 					
					
     // 此时文件按 JSON 文件解析					
          require('./module.json'); 					
					
     // 此时文件预编译好的 C++ 模块执行					
          require('./module.node');					
					
     // 载入目录module目录中的 package.json 中main指向的文件					
          require('./module/default.js'); 					
					
     // 载入目录module 中的index.js文件					
     通过 ./ 或 ../ 开头：则按照相对路径从当前文件所在文件夹开始寻找模块；					
         require('../file.js'); => 上级目录下找 file.js 文件					
					
     通过 / 开头：则以系统根目录开始寻找模块；					
          require('/Users/iceStone/Documents/file.js'); => 以绝对路径的方式找,没有任何异议					
					
     如果参数字符串不以“./“ 或 ”/“ 开头，则表示加载的是一个默认提供的核心模块（位于 Node 的系统安装目录中）：					
          require('fs'); => 加载核心模块中的文件系统模块					
					
     或者从当前目录向上搜索 node_modules 目录中的文件：					
          require('my_module'); => 各级 node_modules 文件夹中搜索 my_module.js 文件；					
					
     如果 require 传入的是一个目录的路径，会自动查看该目录的 package.json 文件，然后加载 main 字段指定的入口文件					
					
     如果package.json文件没有main字段，或者根本就没有package.json文件，则默认找目录下的 index.js 文件作为模块：					
          require('./calcuator'); => 当前目录下找 calculator 目录中的 index.js 文件					
					
2、require缓存					
     第一次加载某个模块时，Node 会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的 module.exports 属性（不会再次执行该模块）					
     如果需要多次执行模块中的代码，一般可以让模块暴露行为（函数），模块的缓存可以通过 require.cache 拿到，同样也可以删除					
					
3、所有代码都运行在模块作用域，不会污染全局作用域。					
					
二、模拟require函数					
require的加载内部比较复杂，下面让我们进行简单的模拟加载					
require的简单实现机制为：					
     将传入的模块id通过加载规则找到对应的模块文件					
     读取这个文件里面的代码					
     通过拼接方式为该段代码构建私有空间					
     执行该代码					
     拿到module.exports 返回					
nodejs_require.js					
// [require函数模拟]					
					
"use strict"					
					
function $require(id) {					
//1、先查看模块是否存在，如果不存在则抛出 Can't found file					
//2、如果存在，就读取代码					
const fs = require('fs');					
const path = require('path');					
					
// 文件名					
let filename = id;					
//查看是否是绝对路径					
if (!path.isAbsolute(filename)) {					
 filename = path.join(__dirname, id);					
}					
					
// 文件目录					
let dirname = path.dirname(filename);					
					
//模拟require的缓存机制					
$require.cache = $require.cache || {};					
if($require.cache[filename]){					
 return $require.cache[filename].exports;					
}					
					
// 读取模块代码					
let code="";					
try {					
 code = fs.readFileSync(filename,'utf-8'); // 阻塞读取文件，不会放入事件队列 					
} catch (error) {					
 console.log(" [*]can't found file! ");					
 throw error;					
}					
					
// console.log(code);					
					
// 3、执行代码，所要执行的代码，需要营造一个独立的空间					
					
// 定义一个数据容器，用容器去装模块导出的成员					
let _module = { // 每个js模块都会有一个全局的module变量					
 id:'.',					
 exports:{},					
 parent:module,					
 filename:filename					
};					
let _exports = _module.exports;					
					
// 营造一个独立空间					
code = `(function($require,module,_exports,__dirname,__filename){					
 $[code]					
})($require,_module,_exports,dirname,filename)`;					
					
// 执行代码					
eval(code);					
					
// 缓存					
$require.cache[filename] = _module;					
// 返回结果					
return _module.exports;					
}					
					
					
setInterval(()=>{					
 const rr = $require("./test.js");					
 console.log(rr);					
},1000);					
					
上面的模块测试使用的两个模块					
//test.js					
const date = $require('./date.js');					
					
console.log(module);					
					
module.exports = date;					
					
//date.js					
module.exports = new Date();					



