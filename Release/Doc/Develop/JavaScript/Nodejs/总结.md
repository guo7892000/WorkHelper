## Nodejs-总结
### 静态资源：						
	对于静态资源的请求，可通过 app设置(var app = express.createServer();)					
	app.use(’/WebContent’, express.static(__dirname + ‘/WebContent’)) 假如监听IP为 localhost;端口为 3000, 这个表示的意思就是 URL为 http://localhost:3000/WebContent/a/b/c.html 将访问 server.js 所在目录的 a/b/c.html					
						
	可以用res.sendfile实现直抛静态。					
	在开发过程中，可以使用 res.sendFile() 提供静态文件。但是，请勿在生产环境中执行此函数，因为它必须针对每次文件请求读取文件系统，所以会产生严重的延迟，影响应用程序的总体性能。					
	请注意，res.sendFile() 并非通过效率要高很多的 sendfile 系统调用来实现的。 因此，建议使用 serve-static 中间件（或者等效项），该中间件经过优化，用于为 Express 应用程序提供文件。 还有一个更好的选项，就是使用逆向代理提供静态文件；					
						
### Nodejs常用命令：						
	$npm install按照package.json的定义安装所有依赖					
	$npm start启动程序, 浏览器访问localhost:3000即可.					
						
	$npm install -g nodemon					
	然后使用nodemon指令代替npm start启动应用程序.					
	如果你只是修改了Jade模板, CSS文件, 或者客户端的js代码, 无需重新启动应用					
						
### charset字符集：						
	包括：utf-8、gb2312等。一般使用uft-8，其也能解析中文。					
						
### 相对index.html所有的目录而言：						
	/表示根目录					
	./表示源文件所在目录					
	../表示源文件所在目录的上一级目录					
	../../表示源文件所在目录的上上级目录，以此类推。					
						
### 问题：ejs里面的img图片路径是正确的但是加载不出来。 						
	原因：					
		出现这种情况的原因就是使用了express的框架的静态服务：				
		app.use(express.static(path.join(__dirname, ‘public’)));				
						
	解决办法：					
	就是讲所有的静态资源文件都托管到public文件夹里，					
	然后所有需要调用img图片什么的不管你在哪个文件夹,你都把自己当成是public文件夹即可。					
	<div class="hd_logo"><img src="/resources/images/web/logo.png"/> </div>					
						
						
### 参数传值：						
	//request.query.pwd 与 request.param("pwd") 这两种方式一致  					
	//只能针对get方法，如果form表单是post提交方式，则无效  					
	  var username = request.param(username);  					
	  var pwd = request.param(pwd);  					
						
	//针对Post方法：					
	var userName = request.body.username,  					
	      userPwd = request.body.pwd,  					
	      userName2 = request.param('pwd'),  					
	      userPwd2 = request.param('username');  					
						
### Node.js中package.json中库的版本号详解(^和~区别)：						
						
	波浪符号（~）：他会更新到当前minor version（也就是中间的那位数字）中最新的版本。放到我们的例子中就是：body-parser:~1.15.2，这个库会去匹配更新到1.15.x的最新版本，如果出了一个新的版本为1.16.0，则不会自动升级。					
	波浪符号是曾经npm安装时候的默认符号，现在已经变为了插入符号。					
	插入符号（^）：这个符号就显得非常的灵活了，他将会把当前库的版本更新到当前major version（也就是第一位数字）中最新的版本。放到我们的例子中就是：bluebird:^3.3.4，这个库会去匹配3.x.x中最新的版本，但是他不会自动更新到4.0.0。					
	总结一下：					
	~1.15.2 表示： 1.15.2 <= 更新的版本 < 1.16.0     					
	^3.3.4 表示： 3.3.4 <= 更新的版本 < 4.0.0					
	"latest"表示：最新版本					
						
	最后解释下之前提到的minor verision和major version：					
	1.15.2对应就是MAJOR,MINOR.PATCH：1是marjor version；15是minor version；2是patch version。					
	MAJOR：这个版本号变化了表示有了一个不可以和上个版本兼容的大更改。					
	MINOR：这个版本号变化了表示有了增加了新的功能，并且可以向后兼容。					
	PATCH：这个版本号变化了表示修复了bug，并且可以向后兼容。					
	因为major version变化表示可能会影响之前版本的兼容性，所以无论是波浪符号还是插入符号都不会自动去修改major version，因为这可能导致程序crush，可能需要手动修改代码。					
						
						
### 创建Nodejs项目：						
	1、自行创建目录结构：					
		$ npm init				
		$ npm install express --save				
	2、利用express-generator生成工程目录：					
		创建一个名为“myapp”的Express应用：在当前目录下创建子目录myapp，视图引擎为pug。				
		$ express --view=pug myapp				
		或：$express --view=ejs myapp				
						
						
### nodejs使用request发送http请求						
	在nodejs的开发中，有时需要后台去调用其他服务器的接口，这个时候，就需要发送HTTP请求了。有一个简单的工具可以用，Simplified HTTP request client，可以比较方便的模拟请求。					
	安装					
						
	npm install --save request					
						
	使用					
						
	最简单的GET请求，用法如下：					
						
	var request = require('request');					
	request('http://www.baidu.com', function (error, response, body) {					
	  if (!error && response.statusCode == 200) {					
	    console.log(body) // Show the HTML for the baidu homepage.					
	  }					
	})					
						
	POST application/json					
						
	request({					
	    url: url,					
	    method: "POST",					
	    json: true,					
	    headers: {					
	        "content-type": "application/json",					
	    },					
	    body: JSON.stringify(requestData)					
	}, function(error, response, body) {					
	    if (!error && response.statusCode == 200) {					
	    }					
	}); 					
						
	POST application/x-www-form-urlencoded					
						
	request.post({url:'http://service.com/upload', form:{key:'value'}}, function(error, response, body) {					
	    if (!error && response.statusCode == 200) {					
	    }					
	})					
						
						
	POST multipart/form-data					
						
	var formData = {					
	    // Pass a simple key-value pair					
	    my_field: 'my_value',					
	    // Pass data via Buffers					
	    my_buffer: new Buffer([1, 2, 3]),					
	    // Pass data via Streams					
	    my_file: fs.createReadStream(__dirname + '/unicycle.jpg'),					
	};					
	request.post({url:'http://service.com/upload', formData: formData}, function (error, response, body) {  					
	    if (!error && response.statusCode == 200) {					
	    }					
	})					
						
	如上所示，formData可以直接放key-value格式的数据，也可以放buffer，或者是通过流描述的文件。					
						
### npm 5.0版本之后，npm install后都会有一个package-lock.json,作用是什么？						
	1、锁定安装时的包的版本号，需要上传到git，保证大家的依赖包一致。					
	2、package-lock.json 是在 `npm install`时候生成一份文件，用来记录当前状态下实际安装的各个npm package的具体来源和版本号。					
	3、它有什么用呢？因为npm是一个用于管理package之间依赖关系的管理器，它允许开发者在pacakge.json中间标出自己项目对npm各库包的依赖。你可以选择以如下方式来标明自己所需要库包的版本；例如：					
	"dependencies": {					
	 "@types/node": "^8.0.33",					
	},					
	这里面的 向上标号^是定义了向后（新）兼容依赖，指如果 types/node的版本是超过8.0.33，并在大版本号（8）上相同，就允许下载最新版本的 types/node库包，例如实际上可能运行npm install时候下载的具体版本是8.0.35。					
	大多数情况这种向新兼容依赖下载最新库包的时候都没有问题，可是因为npm是开源世界，各库包的版本语义可能并不相同，有的库包开发者并不遵守严格这一原则：相同大版本号的同一个库包，其接口符合兼容要求。这时候用户就很头疼了：					
	在完全相同的一个nodejs的代码库，在不同时间或者不同npm下载源之下，下到的各依赖库包版本可能有所不同，因此其依赖库包行为特征也不同有时候甚至完全不兼容。					
	解决：					
	　　因此npm最新的版本就开始提供自动生成package-lock.json功能，为的是让开发者知道只要你保存了源文件，到一个新的机器上、或者新的下载源，只要按照这个package-lock.json所标示的具体版本下载依赖库包，就能确保所有库包与你上次安装的完全一样。					
	4、package.json缺点					
	　　原来package.json文件只能锁定大版本，也就是版本号的第一位，并不能锁定后面的小版本，你每次npm install都是拉取的该大版本下的最新的版本，为了稳定性考虑我们几乎是不敢随意升级依赖包的，这将导致多出来很多工作量，测试/适配等，					
	　　所以package-lock.json文件出来了，当你每次安装一个依赖的时候就锁定在你安装的这个版本。					
	5、安装依赖出问题的解决方式不同：					
	　　那如果我们安装时的包有bug，后面需要更新怎么办？					
	以前：在以前可能就是直接改package.json里面的版本，然后再npm install了。					
	现在：但是5版本后就不支持这样做了，因为版本已经锁定在package-lock.json里了，所以我们只能npm install xxx@x.x.x  这样去更新我们的依赖，然后package-lock.json也能随之更新。					
	例如：					
	假如我已经安装了jquery 2.1.4这个版本，从git更新了package.json和package-lock.json，我npm install能覆盖掉node_modules里面的依赖吗?					
	其实我也有这个疑问，所以做了测试，在直接更新package.json和package-loc.json这两个文件后，npm install是可以直接覆盖掉原先的版本的，所以在协作开发时，这两个文件如果有更新，你的开发环境应该npm install一下才对。					
	本人在实际工程中曾经在Github下载了一个项目的源码后，执行npm i时报错；后来删除package-lock.json文件后，重新执行npm i后就没报错了，并且重新生成了package-lock.json文件。原因个人估计是该项目在其他项目基础上裁剪的，修改了package.json后，并没有同步修改package-lock.json导致。					

	其实用一句话来概括很简单，就是锁定安装时的包的版本号，并且需要上传到git，以保证其他人在npm install时大家的依赖能保证一致。
在以前可能就是直接改package.json里面的版本，然后再npm install了，但是5版本后就不支持这样做了，因为版本已经锁定在package-lock.json里了，
所以我们只能npm install xxx@x.x.x  这样去更新我们的依赖，然后package-lock.json也能随之更新。
