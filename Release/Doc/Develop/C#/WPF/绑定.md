## WPF-绑定
### DataTemplate的五种使用方式							
	学习数据模板的过程中，遇到过几种不同的使用方法：						
	代码中嵌套						
	资源引用 key						
	DataType 引用 后台类型，例如：Student类等等						
	DataType 引用 XmlDataProvider						
	Style 设置						
							
	Student 类定义如下：包含 Id、姓名、年龄几个属性 .						
	class Student						
	{						
	        public int Id { get; set; }						
	        public string Name { get; set; }						
	        public int Age { get; set; }						
	}						
							
	代码中嵌套						
	我们将 ListBox的内容使用一个模板，下面这种模板风格我称之为内容嵌套模板：						
	<Grid>						
	        <ListBox x:Name="lb">						
	            <ListBox.ItemTemplate>						
	                <DataTemplate>						
	                    <StackPanel Orientation="Horizontal">						
	                        <TextBlock Text="{Binding Id}" Width="60"/>						
	                        <TextBlock Text="{Binding Name}" Width="120"/>						
	                        <TextBlock Text="{Binding Age}" Width="60"/>						
	                    </StackPanel>						
	                </DataTemplate>						
	            </ListBox.ItemTemplate>						
	        </ListBox>						
	</Grid>						
	模板内容是将三个 TextBlock的内容分别绑定 Student类的各个属性，并设置宽度						
	为 ListBox的 itemsSource赋值：						
	List<Student> list = new List<Student>()						
	{						
	        new Student(){Id = 1,Name = "huameng", Age = 20},						
	        new Student(){Id = 2,Name = "flower", Age = 30},						
	        new Student(){Id = 3,Name = "dreams", Age = 22},						
	        new Student(){Id = 4,Name = "cong", Age = 24},						
	        new Student(){Id = 5,Name = "xiaoxu", Age = 11},						
	        new Student(){Id = 6,Name = "giaogiao", Age = 23},						
	};						
							
	this.lb.ItemsSource = list;						
							
	资源引用 KEY						
	我们可以将DataTemplate当作一个资源来引用它，代码如下：						
	    <Window.Resources>						
	        <DataTemplate x:Key="dt">						
	            <StackPanel Orientation="Horizontal">						
	                <TextBlock Text="{Binding Id}" Width="60"/>						
	                <TextBlock Text="{Binding Name}" Width="120"/>						
	                <TextBlock Text="{Binding Age}" Width="60"/>						
	            </StackPanel>						
	        </DataTemplate>						
	    </Window.Resources>						
							
	    <Grid>						
	        <ListBox x:Name="lb" ItemTemplate="{StaticResource dt}"/>						
	    </Grid>						
							
	DATATYPE 引用 后台类型						
	前两篇文章中，我们使用DataType为某一种类型设置模板，下面的例子是使用后台的Student类当作类型来设置，在之前的文章中，这个例子没有出现过 . . .						
	我们把之前在后台定义的一些数据，这次直接定义在XAML中，代码如下：						
	<Window.Resources>						
	        <DataTemplate DataType="{x:Type local:Student}">						
	            <StackPanel Orientation="Horizontal">						
	                <TextBlock Text="{Binding Id}" Width="60"/>						
	                <TextBlock Text="{Binding Name}" Width="120"/>						
	                <TextBlock Text="{Binding Age}" Width="60"/>						
	            </StackPanel>						
	        </DataTemplate>						
							
	        <e:ArrayList x:Key="al">						
	            <local:Student Id = "1" Name = "huameng" Age = "20"/>						
	            <local:Student Id = "2" Name = "flower" Age = "30"/>						
	            <local:Student Id = "3" Name = "dreams" Age = "22"/>						
	            <local:Student Id = "4" Name = "cong" Age = "24"/>						
	            <local:Student Id = "5" Name = "xiaoxu" Age = "11"/>						
	            <local:Student Id = "6" Name = "giaogiao" Age = "23"/>						
	        </e:ArrayList>						
							
	</Window.Resources>						
							
	<Grid>						
	        <ListBox x:Name="lb" ItemsSource="{Binding Source={StaticResource al}}"/>						
	</Grid>						
	这样我们就不需要在后台那样定义数据了						
	这里用DataType可以为Student类型的数据定义统一的模板						
							
	DATATYPE 引用 XMLDATAPROVIDER						
	像上面这个例子，我们定义数据还要定义专门的数据类型，这样会把后台与UI 难免的会联系在一起，这样就违反了WPF的设计理念 . . .						
	我们可以Xml来存储数据，然后在资源中引用，下面的这些数据，我们直接定义在XmlDataProvider中，方便本例的操作 . . .						
	代码如下：						
	<Window.Resources>						
	        <DataTemplate DataType="Student">						
	            <StackPanel Orientation="Horizontal">						
	                <TextBlock Text="{Binding XPath=@Id}" Width="60"/>						
	                <TextBlock Text="{Binding XPath=@Name}" Width="120"/>						
	                <TextBlock Text="{Binding XPath=@Age}" Width="60"/>						
	            </StackPanel>						
	        </DataTemplate>						
							
	        <XmlDataProvider x:Key="xdp" XPath="Students/Student">						
	            <x:XData>						
	                <Students xmlns="">						
	                    <Student Id = "1" Name = "huameng" Age = "20"/>						
	                    <Student Id = "2" Name = "flower" Age = "30"/>						
	                    <Student Id = "3" Name = "dreams" Age = "22"/>						
	                    <Student Id = "4" Name = "cong" Age = "24"/>						
	                    <Student Id = "5" Name = "xiaoxu" Age = "11"/>						
	                    <Student Id = "6" Name = "giaogiao" Age = "23"/>						
	                </Students>						
	            </x:XData>						
	        </XmlDataProvider>						
	</Window.Resources>						
							
	<StackPanel>						
	        <ListBox x:Name="lb" ItemsSource="{Binding Source={StaticResource xdp}}"/>						
	</StackPanel>						
							
	STYLE 设置						
	我们可以在 Style中设置我们需要的模板，控件模板 Template，或者我们本例需要的数据模板ContentTemplate . . .						
	<Window.Resources>						
	        <Style TargetType="ListBoxItem">						
	            <Style.Setters>						
	                <Setter Property="ContentTemplate">						
	                    <Setter.Value>						
	                        <DataTemplate DataType="Student">						
	                            <StackPanel Orientation="Horizontal">						
	                                <TextBlock Text="{Binding XPath=@Id}" Width="60"/>						
	                                <TextBlock Text="{Binding XPath=@Name}" Width="120"/>						
	                                <TextBlock Text="{Binding XPath=@Age}" Width="60"/>						
	                            </StackPanel>						
	                        </DataTemplate>						
	                    </Setter.Value>						
	                </Setter>						
	            </Style.Setters>						
	        </Style>						
	        						
	        <XmlDataProvider x:Key="xdp" XPath="Students/Student">						
	            <x:XData>						
	                <Students xmlns="">						
	                    <Student Id = "1" Name = "huameng" Age = "20"/>						
	                    <Student Id = "2" Name = "flower" Age = "30"/>						
	                    <Student Id = "3" Name = "dreams" Age = "22"/>						
	                    <Student Id = "4" Name = "cong" Age = "24"/>						
	                    <Student Id = "5" Name = "xiaoxu" Age = "11"/>						
	                    <Student Id = "6" Name = "giaogiao" Age = "23"/>						
	                </Students>						
	            </x:XData>						
	        </XmlDataProvider>						
							
	</Window.Resources>						
							
	<StackPanel>						
	        <ListBox ItemsSource="{Binding Source={StaticResource xdp}}"/>						
	</StackPanel>						
	在 Style中设置我们需要的模板属性，一般是配合 Trigger使用						
							
### WPF之DataTemplate的使用							
	一 概要						
	通过实例演示DataTemplate的基本用法，并通过实例来说明DataTemplate相关知识点。						
	二 实例操作						
	1 新建WPF应用程序WpfTemplateExp，程序结构如下图所示。						
	程序最终的运行效果如下图所示。						
							
	程序完成的功能是：						
	通过列表显示学生信息，并在选中某学生时，在列表下方的文本框中显示该生的总评信息。						
							
	2 新建实体类Student（类文件名为Student.cs），详细代码如下所示。						
	namespace WpfTemplateExp						
	{						
	    public class Student						
	    {						
	        public int ID { get; set; }						
	        public string Name { get; set; }						
	        public string Sex { get; set; }						
	        public int Score { get; set; }						
	        public string Judge { get; set; }						
	    }						
	}						
	3 修改MainWindow.xaml文件，编写程序主画面代码，详细代码如下所示。						
							
	<Window x:Class="WpfTemplateExp.MainWindow"        						
	        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"						
	        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"						
	        xmlns:local="clr-namespace:WpfTemplateExp"						
	        Title="MainWindow" Height="350" Width="525" WindowStyle="ToolWindow">						
	    <Window.Resources>						
	        <local:NameToImagePathConverter x:Key="ncvt"/>						
	        <local:ScoreToImagePathConverter x:Key="scvt"/>						
	        <DataTemplate x:Key="studentItemTemplate">						
	            <Grid>						
	                <StackPanel Orientation="Horizontal" >						
	                    <Image Source="{Binding Name,Converter={StaticResource ncvt}}" Width="64" Height="64"/>						
	                    <TextBlock Text="{Binding ID}" Margin="10,10,5,10" Width="100"/>						
	                    <TextBlock Text="{Binding Name}" Margin="10,10,5,10" Width="100"/>						
	                    <TextBlock Text="{Binding Sex}" Margin="10,10,5,10" Width="50"/>						
	                    <TextBlock Text="{Binding Score}" Margin="10,10,5,10" Width="50"/>						
	                    <Image Source="{Binding Score,Converter={StaticResource scvt}}" Width="64" Height="64"/>						
	                </StackPanel>						
	            </Grid>						
	        </DataTemplate>						
	        <DataTemplate x:Key="studentJudgeTemplate">						
	            <TextBlock Text="{Binding Judge}"/>						
	        </DataTemplate>						
	    </Window.Resources>						
	    <Grid>						
	        <Grid.RowDefinitions>						
	            <RowDefinition Height="8*"></RowDefinition>						
	            <RowDefinition Height="2*"></RowDefinition>						
	        </Grid.RowDefinitions>						
	        <ListBox x:Name="ListBox_StudentList" Grid.Row="0" ItemTemplate="{StaticResource studentItemTemplate}"/>						
	        <UserControl Grid.Row="1" ContentTemplate="{StaticResource studentJudgeTemplate}" Content="{Binding SelectedItem,ElementName=ListBox_StudentList}"/>       						
	    </Grid>						
	</Window>						
	 						
	4 编写程序主画面的后端代码（文件MainWindow.xaml.cs），详细代码如下所示。						
	using System.Collections.Generic;						
	using System.Windows;						
	using System.Windows.Documents;						
	 						
	namespace WpfTemplateExp						
	{						
	    /// <summary>						
	    /// MainWindow.xaml 的交互逻辑						
	    /// </summary>						
	    public partial class MainWindow : Window						
	    {						
	        public MainWindow()						
	        {						
	            InitializeComponent();						
	            List<Student> studentList = new List<Student>() 						
	            {						
	                new Student(){ID=1000,Name="zhangsan",Sex="男",Score=82,Judge="zhangsan(学号:1000，性别：男) 同学,此次考试的成绩是82分，合格。"},						
	                new Student(){ID=1001,Name="lisi",Sex="女",Score=33,Judge="lisi(学号:1001，性别：女) 同学,此次考试的成绩是33分，不合格。"},						
	                new Student(){ID=1002,Name="wangwu",Sex="男",Score=56,Judge="wangwu(学号:1002，性别：男) 同学,此次考试的成绩是56分，不合格。"},						
	                new Student(){ID=1003,Name="zhaosi",Sex="女",Score=98,Judge="zhaosi(学号:1003，性别：女) 同学,此次考试的成绩是98分，合格。"}						
	            };						
	            this.ListBox_StudentList.ItemsSource = studentList;						
	        }						
	    }						
	}						
	 						
	4 实现数据转换器类						
	根据学生姓名生成学生照片，以及根据学生成绩生成“合格与否”的标志图片（对号和叉号）时，都需要用到数据转换器，						
	它们是实现了IValueConverter接口的类NameToImagePathConverter与类ScoreToImagePathConverter，下面给出两者的完整代码。						
	4.1 NameToImagePathConverter类（类文件名为NameToImagePathConverter.cs）						
	using System;						
	using System.Globalization;						
	using System.Windows.Data;						
	using System.Windows.Media.Imaging;						
	 						
	namespace WpfTemplateExp						
	{						
	    public class NameToImagePathConverter: IValueConverter						
	    {						
	        public object Convert(object value, Type targertType, object parameter, CultureInfo culture)						
	        {						
	            string strUri = string.Format(@"/images/{0}.jpg",(string)value);						
	            return new BitmapImage(new Uri(strUri,UriKind.Relative));						
	        }						
	        public object ConvertBack(object value, Type targertType, object parameter, CultureInfo culture)						
	        {						
	            throw new NotImplementedException();						
	        }						
	    }						
	}						
							
	4.2 ScoreToImagePathConverter类（类文件名为ScoreToImagePathConverter.cs）						
	using System;						
	using System.Globalization;						
	using System.Windows.Data;						
	using System.Windows.Media.Imaging;						
	 						
	namespace WpfTemplateExp						
	{						
	    public class ScoreToImagePathConverter : IValueConverter						
	    {						
	        public object Convert(object value, Type targertType, object parameter, CultureInfo culture)						
	        {						
	            int score =(int)value;						
	            string strUri;						
	            if (score >= 60) 						
	            {						
	                strUri = @"/images/right.jpg";						
	            }						
	            else						
	            {						
	                strUri = @"/images/wrong.jpg";						
	            }						
	            return new BitmapImage(new Uri(strUri, UriKind.Relative));						
	        }						
	        public object ConvertBack(object value, Type targertType, object parameter, CultureInfo culture)						
	        {						
	            throw new NotImplementedException();						
	        }						
	    }						
	}						
	至此，程序完成，程序的运行效果如图2所示。						
	下面将结合示例程序的代码对DataTemplate知识点进行阐述说明。						
	按照字面意思，可以将DataTemplate翻译为“数据模板”，那么为什么要使用“数据模板”来显示对象数据呢，下面将慢慢道来						
							
	1 为什么需要DataTemplate？						
	在WPF中，可以使用DataTemplate来描述数据对象的可视结构。						
	这句话的意思是：在WPF中，将数据对象绑定至画面元素时，可以使用DataTemplate定义数据对象的外观，这样做的好处是，可以使数据对象获得更好的显示效果，						
	因为在没有使用DataTemplate的情况下，默认显示的是对象的字符串表示形式（ToString方法的返回值），这种实现在实际开发中往往无法满足业务要求，就算重写ToString方法能够勉强实现数据显示的功能，						
	但是也不够灵活，无法控制对象中每个属性的显示效果，要想实现本例中将某些属性显示成图片的效果，就更难上加难。为了能够更好地说明DataTemplate的作用，我们可以进行以下尝试：						
	将实例中DataTemplate的定义代码注释掉，同时去掉使用DataTemplate的代码，再次运行程序，又能得到什么样的显示效果呢?						
							
	需要处理掉的代码包含以下两部分：						
	1)需要注释掉的代码：						
	<DataTemplate x:Key="studentItemTemplate">...省略了一大段</DataTemplate>						
							
	2)需要去掉的代码：						
	ItemTemplate="{StaticResource studentItemTemplate}"      						
	（位于代码<ListBox x:Name="ListBox_StudentList" Grid.Row="0" ItemTemplate="{StaticResource studentItemTemplate}"/>中）						
	运行程序，得到的效果是这样的：						
			
	这次显示的效果是不是好多了，不过要想实现显示学生图片这样的效果的话，通过重写ToString方法还是无法实现，所以本例中借助于DataTemplate 来显示我们的Student对象。						
在我们定义的DataTemplate中，使用TextBlock控件来显示学生的ID，Name，Sex及Score等信息，同时使用Image控件来显示学生的图片以及“合格与否”的标志图片。						
这样一来，便可以通过调整DataTemplate 中控件的属性来改变数据的显示效果。为了在 DataTemplate 中的控件显示对象的属性值，仍然是通过“数据绑定”这个桥梁来连接数据对象与界面元素。说到“绑定”，请接着往下看。						
						
2 DataTemplate中的数据绑定又是怎样实现的呢？						
实例中将Student对象的集合绑定到ListBox控件，并且将ItemTemplate属性设置为实例中定义的DataTemplate，那么在创建ListBox 时，将会依次为集合中的每个Student对象创建一个ListBoxItem，						
并将 ListBoxItem 的 DataContext 设置为相应的Student对象，同时将DataTemplate 中的元素绑定到Student对象的属性，这样DataTemplate中的控件便和对象的属性完成了绑定。						
						
3 是否可以将DataTemplate 定义为资源以提高代码重用性？						
其实在本文给出的实例中，就已经将DataTemplate 定义成了资源，定义成资源的DataTemplate 是一个可以被重用的对象，可以在具有DataTemplate 类型的属性的其他控件中使用它。						
将模板定义成资源的方法很简单，只需在画面对象的Resources属性中定义我们的数据模板并指定一个Key，便可以像使用其他资源一样来使用它。						
						
下面的代码是实例中使用定义成资源的DataTemplate 的代码						
ItemTemplate="{StaticResource studentItemTemplate}"						
在本文实例中，若不希望将DataTemplate当做资源来使用的话，也可以将 DataTemplate 作为 ItemTemplate 属性元素的直接子级，那么使用DataTemplate'的代码也可以是这样的。						
<ListBox x:Name="ListBox_StudentList" Grid.Row="0" >						
    <ListBox.ItemTemplate>						
         <DataTemplate>						
             <Grid>						
                 <StackPanel Orientation="Horizontal" >						
                     <Image Source="{Binding Name,Converter={StaticResource ncvt}}" Width="64" Height="64"/>						
                     <TextBlock Text="{Binding ID}" Margin="10,10,5,10" Width="100"/>						
                     <TextBlock Text="{Binding Name}" Margin="10,10,5,10" Width="100"/>						
                     <TextBlock Text="{Binding Sex}" Margin="10,10,5,10" Width="50"/>						
                     <TextBlock Text="{Binding Score}" Margin="10,10,5,10" Width="50"/>						
                     <Image Source="{Binding Score,Converter={StaticResource scvt}}" Width="64" Height="64"/>						
                 </StackPanel>						
             </Grid>						
         </DataTemplate>						
    </ListBox.ItemTemplate>						
</ListBox>						
						
4 DataTemplate可以应用于哪些控件？						
4.1 ContentControl控件（内容控件）						
被ContentControl控件的Contemplate属性使用。						
最常用的ContentControl控件包括：Button、ButtonBase、CheckBox、ComboBoxItem、Label、ListBoxItem、ListViewItem、RadioButton、ToolTip、UserControl、Window等。						
						
4.2 ItemsControl控件（项控件）						
被ItemsControl控件的ItemTemplate属性。						
最常见的ItemsControl控件包括：Menu、MenuBase、ContextMenu、ComoBox、ListBox、ListView等。						
						
4.3 被GridViewColumn控件的CellTemplate属性使用。						
						
三 总结						
本文通过实例演示了WPF中DatatTemplate的使用方法，并解释了：为什么要使用DatatTemplate以及DatatTemplate中数据绑定的实现原理等知识。						
	
### 控件之间绑定									
	实现一个按钮背景随着List的颜色选项变色。								
	<Window x:Class="WPFdemo5.MainWindow"								
	        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"								
	        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"								
	        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"								
	        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"								
	        xmlns:local="clr-namespace:WPFdemo5"								
	        mc:Ignorable="d"								
	        Title="MainWindow" Height="350" Width="525">								
	    <Grid>								
	        <ListBox x:Name="listBox" HorizontalAlignment="Left" Height="197" Margin="355,58,0,0" VerticalAlignment="Top" Width="127">								
	            <ListBoxItem Height="20" Tag="Red" Content="Red"/>								
	            <ListBoxItem Height="20" Tag="Blue" Content="Blue"/>								
	            <ListBoxItem Height="20" Tag="Green" Content="Green"/>								
									
	        </ListBox>								
	        <Button x:Name="button" Content="Button" HorizontalAlignment="Left" Margin="92,97,0,0"  								
	Background="{Binding ElementName=listBox,Path=SelectedItem.Tag ,Mode=OneWay}" VerticalAlignment="Top" Width="75" Height="80"/>								
	    </Grid>								
	</Window>								
	绑定的代码：								
	Background="{Binding ElementName=listBox,Path=SelectedItem.Tag ,Mode=OneWay}"								
	Binding 中 ElementName=listBox  绑定控件的Name，Path=SelectedItem.Tag  绑定控件的什么属性值，Mode=OneWay 绑定控件的方式								
	A,B两控件： A属性值绑定B属性值								
	TwoWay：双向绑定，两者之间，改一个动两者，B一直变，则A一直变；A一直变则B也一直变								
	OneWay ：单向绑定，B一直变，则A一直变								
	OneTime：单次绑定，B一直变，则A不一直变，只随着A初始值变一次								
	OneWayToSource：逆向绑定，A一直变，则B一直变								
	Default：默认，一般情况下用户可编辑控件属性（例如文本框和复选框的属性）默认为双向绑定，而多数其他属性默认为单向绑定。								
									
	后台代码绑定和解绑								
	            //声明和初始化绑定								
	            Binding b = new Binding();								
	            //绑定源，控件name								
	            b.Source = this.listBox;								
	            //绑定源的属性值								
	            b.Path = new PropertyPath("SelectedItem.Tag");								
	            //绑定方式								
	            b.Mode = BindingMode.OneWay;								
	            //要绑定控件的属性，绑定对象								
	            this.button.SetBinding(Button.BackgroundProperty, b);								
									
									
	            //删除绑定								
	            BindingOperations.ClearAllBindings(this.button);								
	

### DataContext		
在WPF中，应用程序有两层：UI层和Data层。这里新建一个项目说明哪些是UI层，哪些是数据层。	
UI层很明显，就是用户看到的界面。但是数据层并不是下图所示：
																	
	是不是惨不忍睹啊，原因在前面已经说明过，因为在没有使用DataTemplate的情况下，默认显示的是对象的字符串表示形式，也就是将调用对象的ToString()方法后的返回值显示出来。						
	为了显示Student对象所有属性的值，我们重写Student类的ToString方法，重写后的ToString方法如下所示。						
	public override string  ToString()						
	{						
	     return ID.ToString() +"   " + Name.ToString() +"   " + Sex.ToString() + "   " + Score.ToString();						
	}						
	再次运行程序，得到下图所示的执行效果						
	上图中是UI层view的后台代码。当然，你可以使用事件的方式把所有的业务逻辑代码写到这里，但是我们采用MVVM的时候业务逻辑是与这里解耦的，数据层是DataContext，此时并没有指定。	
接下来我们新建个目录，然后添加个类文件：	
然后指定VM类为DataContext：
此时我们才算为MVVM模式的wpf应用程序创建了数据层，也就是MainViewModel类。							
默认，应用程序的数据层（DataContext）是null，我们可以使用DataContext属性对其进行设置。							
除非另行指定，否则所有UI对象都将从其父对象继承其DataContext。							
实际上DataContext才算是我们的实际应用程序（业务逻辑），他通常由ViewModels和Models组成。							
UI对象（如按钮，标签，DataGrids甚至Windows）实际作用是允许用户轻松与DataContext交互。							
当你写<Label Name="myLabel" Content="{Binding Path=Name}" />你是绑定到myLabel.DataContext.Name，而不是myLabel.Name。							
							
<!-- 注意此时我已经在初始化代码中设置DataContext 为 ClassA，DataContext = new ClassA  -->							
<Window x:Name="MyWindow"> 							
 							
    <!-- DataContext 没有被指定,所以继承自父类							
         的 DataContext,也就是 ClassA -->							
    <StackPanel> 							
 							
        <!-- DataContext 继承自父类,也就是 							
             ClassA, 所以这里会显示 ClassA.Name -->							
        <Label Content="{Binding Name}" />							
 							
         <!-- DataContext 仍然是ClassA, 但是我们通过binding设置为ClassA.ClassB-->							
        <StackPanel DataContext="{Binding ClassB}">							
 							
            <!-- DataContext 继承自父类，也就是ClassB，所以这里会显示 ClassB.Name -->							
            <Label Content="{Binding Name}" />							
 							
            <!-- DataContext i仍然是 ClassB, 但是我们binding 到了Window's DataContext.Name, 也就是 ClassA.Name -->							
            <Label Content="{Binding 							
                       ElementName=MyWindow, 							
                       Path=DataContext.Name}" /> 							
        </StackPanel>							
 							
        <!-- We've left the StackPanel with its DataContext 							
             bound to ClassB, so this Label's DataContext 							
             is ClassA (inherited from parent StackPanel), 							
             and we are binding to ClassA.ClassB.Name -->							
        <Label Content="{Binding ClassB.Name}" />							
    </StackPanel>							
</Window>							
所有基本绑定都在UI对象的数据层（DataContext）中寻找它们的值。							
综上所述，WPF应用程序具有两层：UI层和数据层。应用程序的数据层以null开头，可以使用DataContext属性设置。未设置DataContext的UI对象将从其父对象继承其数据层。绑定用于在数据层中查找值，并在UI层中显示它们。							
使用MVVM设计模式时，数据层是您的应用程序，而UI层只是提供了一种用户友好的方式来访问数据层。							
datacontext的绑定							
可以在view的后台代码中手动指定例如在构造函数中：							
							
var cont = new MainViewModle();							
DataContext = cont;							
另外也可以写到资源中，首先需要写一个viewmodel类：							
							
public MainViewModel()							
{							
    plusCommand = new PlusCommand(this);							
}							
然后把vm类放到资源中：							
							
<!--需要指定名称空间vm:							
xmlns:vm="clr-namespace:SimpleCommandDemoApp.ViewModels"-->							
<UserControl.Resources>							
    <vm:CalculatorViewModel x:Key="calculatorVM" />							
</UserControl.Resources>							
最后就可以在xaml中指定了：							
							
DataContext="{Binding Source={StaticResource calculatorVM}}"							
WPF使用DataContext将数据层与UI层实现了解耦，那么他们之间是如何交互的？实际上上面已经略有涉猎，那就是Binding，上面实例的ClassA、ClassB的Name就是通过Binding来展示到UI上的							

### WPF中INotifyPropertyChanged用法与数据绑定								
	在WPF中进行数据绑定的时候常常会用到INotifyPropertyChanged接口来进行实现，下面来看一个INotifyPropertyChanged的案例。							
								
	下面定义一个Person类：							
	using System;							
	using System.Collections.Generic;							
	using System.Linq;							
	using System.Text;							
	using System.ComponentModel;							
	 							
	namespace WpfApp							
	{							
	    public class Person:INotifyPropertyChanged							
	    {							
	        private String _name = "张三";							
	        private int _age = 24;							
	        private String _hobby = "篮球";							
	          							
	        public String Name							
	        {							
	            set							
	            {							
	                _name = value;							
	                if (PropertyChanged != null)//有改变							
	                {							
	                    PropertyChanged(this, new PropertyChangedEventArgs("Name"));//对Name进行监听							
	                }							
	            }							
	            get							
	            {							
	                return _name;							
	            }							
	        }							
	 							
	        public int Age							
	        {							
	            set							
	            {							
	                _age = value;							
	                if (PropertyChanged != null)							
	                {							
	                    PropertyChanged(this, new PropertyChangedEventArgs("Age"));//对Age进行监听							
	                }							
	            }							
	            get							
	            {							
	                return _age;							
	            } 							
	        }							
	        public String Hobby//没有对Hobby进行监听							
	        {							
	            get { return _hobby; }							
	            set { _hobby = value; }							
	        }							
	        public event PropertyChangedEventHandler PropertyChanged;							
	    }							
	}							
	上面定义的这个Person类中，对Name和Age属性进行了监听，但是没有对Hobby进行监听。							
	MainWindow.xmal界面文件定义的内容如下：							
								
	<Window x:Class="WpfApp.MainWindow"							
	        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"							
	        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"							
	        Title="MainWindow" Height="300" Width="350">							
	    <Grid Name="grid"> 							
	        <TextBox Height="20" Text="{Binding Path=Name}"  HorizontalAlignment="Left" Margin="63,12,0,0" Name="textBox1" VerticalAlignment="Top" Width="139" />							
	        <TextBox Height="20"  Text="{Binding Path=Age}"  HorizontalAlignment="Left" Margin="63,48,0,0" Name="textBox2" VerticalAlignment="Top" Width="139" />							
	        <TextBox Height="20" Text="{Binding Path=Hobby}"  HorizontalAlignment="Left" Margin="63,82,0,0" Name="textBox3" VerticalAlignment="Top" Width="139" />							
	        							
	        <Button Content="显示用户信息" Height="26" HorizontalAlignment="Left" Margin="60,118,0,0" Name="button1" VerticalAlignment="Top" Width="144" Click="button1_Click" />							
	        <Button Content="修改用户信息" Height="26" HorizontalAlignment="Left" Margin="60,158,0,0" Name="button2" VerticalAlignment="Top" Width="144" Click="button2_Click" />							
	 							
	        <TextBlock Height="40" HorizontalAlignment="Left" Margin="13,201,0,0" Name="textBlock1"   Text="{Binding Path=Name}"  VerticalAlignment="Top" Width="88" />							
	        <TextBlock Height="40" HorizontalAlignment="Left" Margin="118,201,0,0" Name="textBlock2" Text="{Binding Path=Age}" VerticalAlignment="Top" Width="88" />							
	        <TextBlock Height="40" HorizontalAlignment="Left" Margin="222,201,0,0" Name="textBlock3" Text="{Binding Path=Hobby, Mode=TwoWay}" VerticalAlignment="Top" Width="88" />							
	    </Grid>							
	</Window>							
								
	后台代码是：							
	using System;							
	using System.Collections.Generic;							
	using System.Linq;							
	using System.Text;							
	using System.Windows;							
	using System.Windows.Controls;							
	using System.Windows.Data;							
	using System.Windows.Documents;							
	using System.Windows.Input;							
	using System.Windows.Media;							
	using System.Windows.Media.Imaging;							
	using System.Windows.Navigation;							
	using System.Windows.Shapes;							
	 							
	namespace WpfApp							
	{							
	    /// <summary>							
	    /// MainWindow.xaml 的交互逻辑							
	    /// </summary>							
	    public partial class MainWindow : Window							
	    {							
	        public MainWindow()							
	        {							
	            InitializeComponent();							
	        }							
	 							
	        private Person p1 = new Person();							
	        private void button1_Click(object sender, RoutedEventArgs e)							
	        {							
	            grid.DataContext = p1;//绑定数据							
	            p1.Name = "李四"; 							
	            p1.Hobby = "足球";							
	        } 							
	        private void button2_Click(object sender, RoutedEventArgs e)							
	        {   							
	            p1.Age = p1.Age + 1;							
	            p1.Hobby = "足球";							
	        }							
	    }							
	}							
								
	当点击显示用户数据的时候							
	下面看看这些信息具体都来自于哪儿？							
	由于在Person中没有对Hobby进行监听，所以p1.Hobby="足球"这个语句没有起到作用。 点击修改用户信息的时候也是不能修改绑定到界面上的对应Hobby的信息（即使是在界面处写了Mode=TwoWay,也是不能进行绑定的）。							
	所以使用INotifyPropertyChanged的时候，需要对要进行绑定的属性进行显示的设置的，否则绑定的时候是不能进行双向绑定的,即绑定是无效的。							

### DynamicResource与StaticResource的区别								
	什么叫WPF的资源(Resource)?							
	资源是保存在可执行文件中的一种不可执行数据。在WPF的资源中，几乎可以包含图像、字符串等所有的任意CLR对象，只要对象有一个默认的构造函数和独立的属性。							
	也就是说，应用程序中非程序代码的内容，比如点阵图、颜色、字型、动画/影片档以及字符串常量值，可将它们从程序中独立出来，单独包装成"资源(Resource)"。							
	静态资源(Static Resource)，动态资源（Dynamic Resources）。这两者的区别是：静态资源在第一次编译后即确定其对象或值，之后不能对其进行修改。							
	动态资源则是在运行时决定，当运行过程中真正需要时，才到资源目标中查找其值。因此，我们可以动态地修改它。由于动态资源的运行时才能确定其值，因此效率比静态资源要低。							
	资源的范围（层级）：							
	WPF提供一个封装和存取资源(resource)的机制，我们可将资源建立在应用程序的不同范围上。WPF中，资源定义的位置决定了该资源的可用范围。资源可以定义在如下范围中：							
	(1)物件级：此时，资源只能套用在这个Object物件，或套用至该物件的子物件。 							
	(2)文件级：如果将资源定义在Window或Page层级的XAML档中，那么可以套用到这个文件中的所有物件。 							
	(3)应用程序级：如果我们将资源定义在App.xaml 中，那么，就可以将资源套用到应用程序内的任何地方。 							
	(4)字典级：当我们把资源封装成一个资源字典, 定义到一个ResourceDictionary的XAML文件时,就可以在另一个应用程序中重复使用。							
	每一个框架级元素(FrameworkElement 或者FrameworkContentElement)都有一个资源属性。每一个在资源字典中的资源都有一个唯一不重复的键值(key)，在标签中使用x:Key属性来标识它。一般地,键值是一个字符串,但你也可以用合适的扩展标签来设置为其他对象类型。非字符键值资源使用于特定的WPF区域，尤其是风格、组件资源，以及样式数据等。							
	StaticResources的适用场合：							
	（1）在资源第一次引用之后无需再修改资源的值。							
	（2）资源引用不会基于运行时的行为进行重新计算，比如在重新加载Page/Window的时候。							
	（3）当需要设置的属性不是DependencyObject或Freezable类型的时候，用StaticResource。							
	（4）当需要将资源编译到dll中，并打包为程序的一部份，或者希望在各应用程序之间共享时，也使用StaticResource。							
	（5）当需要为一个自定义控件创建一个Theme，并Theme中使用资源，就需要使用StaticResource。因为StaticResource的资源查找行为时可预测的，并且本身包含在Theme中。而对于DynamicResource，即使资源是定义在Theme中，也只能等到运行时确定，导致一些可能意料不到的情况发生。							
	（6）当需要使用资源设置大量的依赖属性（Dependency Property）的时候。							
	由于依赖属性具有属性系统提供的值缓存机制，所以，如果能在程序装载时设置依赖属性的值，这样，依赖属性就不需要检查自己的值并返回最后的有效值了。							
								
	Dynamic Resource一般使用在如下场合：							
	（1）资源的值依赖一些条件，而该条件直到运行时才能确定。							
	包括系统资源，或是用户可设置的资源。比如：可以创建引用系统属性诸如SystemColors,SystemFonts来设置值，而这些属性是动态的，它们的值又来自于运行环境和操作系统。							
	（2）为自定义控件引用或创建Theme Style。							
	（3）希望在程序运行期间调整资源字典的内容时。							
	（4）希望资源可以向前引用时（如上面在Canvas中引用innerLgbResource一样）							
	（5）资源文件很大，希望在运行时才加载。							
	（6）要创建的Style的值可能来自于其它值，而这些值又依赖于Theme或用户的设置。							
	（7）当引用资源的元素的父元素有可能在运行期改变，这个时候也需要使用动态资源。因为父元素的改变将导致资源查询的范围。							
	Dynamic resource的限制条件：属性必须是依赖属性，或是Freezable的。							
	资源的查询方式							
	Static Resource的查询							
	（1）查找使用该资源的元素的Resource字典；							
	（2）顺着逻辑树向上查找父元素的资源字典，直到根节点；							
	（3）查找Application资源；							
	（4）不支持向前引用，即：不能引用在引用点之后才定义的资源。							
	Dynamic Resource的查询							
	（1）查找使用该资源的元素的Resource字典；							
	如果元素定义了一个Style 属性，将查找Style中的资源字典；如果元素定义了一个Template属性，将查找FrameworkTemplate中的资源字典。							
	（2）顺逻辑树向上查找父元素的资源字典，直到根节点；							
	（3）查找Application资源；							
	（4）查找当前激活状态下的Theme资源字典；							
	（5）查找系统资源。							
								
	<Window.Resources>							
	    <TextBlock x:Key="Res1" Text="海上生明月"></TextBlock>							
	    <TextBlock x:Key="Res2" Text="海上生明月"></TextBlock>							
	</Window.Resources>							
	<StackPanel>							
	    <Button x:Name="button" 							
	            Margin="20" Height="30" Content="{StaticResource Res1}"/>							
	    <Button x:Name="button1" 							
	            Margin="20" Height="30"  Content="{DynamicResource Res2}"/>							
	    <Button x:Name="button2" 							
	            Margin="20" Height="30"  Content="更新" Click="button2_Click"/>							
	</StackPanel>							
								
	private void button2_Click(object sender, RoutedEventArgs e)							
	{							
	    //后台操作资源方法							
	    this.Resources["Res1"] = new TextBlock() {Text="天涯共此时" };							
	    this.Resources["Res2"] = new TextBlock() { Text = "天涯共此时" };							
	}							
						
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
							
	这次显示的效果是不是好多了，不过要想实现显示学生图片这样的效果的话，通过重写ToString方法还是无法实现，所以本例中借助于DataTemplate 来显示我们的Student对象。						
	在我们定义的DataTemplate中，使用TextBlock控件来显示学生的ID，Name，Sex及Score等信息，同时使用Image控件来显示学生的图片以及“合格与否”的标志图片。						
	这样一来，便可以通过调整DataTemplate 中控件的属性来改变数据的显示效果。为了在 DataTemplate 中的控件显示对象的属性值，仍然是通过“数据绑定”这个桥梁来连接数据对象与界面元素。说到“绑定”，请接着往下看。						
							
	2 DataTemplate中的数据绑定又是怎样实现的呢？						
	实例中将Student对象的集合绑定到ListBox控件，并且将ItemTemplate属性设置为实例中定义的DataTemplate，那么在创建ListBox 时，将会依次为集合中的每个Student对象创建一个ListBoxItem，						
	并将 ListBoxItem 的 DataContext 设置为相应的Student对象，同时将DataTemplate 中的元素绑定到Student对象的属性，这样DataTemplate中的控件便和对象的属性完成了绑定。						
							
	3 是否可以将DataTemplate 定义为资源以提高代码重用性？						
	其实在本文给出的实例中，就已经将DataTemplate 定义成了资源，定义成资源的DataTemplate 是一个可以被重用的对象，可以在具有DataTemplate 类型的属性的其他控件中使用它。						
	将模板定义成资源的方法很简单，只需在画面对象的Resources属性中定义我们的数据模板并指定一个Key，便可以像使用其他资源一样来使用它。						
							
	下面的代码是实例中使用定义成资源的DataTemplate 的代码						
	ItemTemplate="{StaticResource studentItemTemplate}"						
	在本文实例中，若不希望将DataTemplate当做资源来使用的话，也可以将 DataTemplate 作为 ItemTemplate 属性元素的直接子级，那么使用DataTemplate'的代码也可以是这样的。						
	<ListBox x:Name="ListBox_StudentList" Grid.Row="0" >						
	    <ListBox.ItemTemplate>						
	         <DataTemplate>						
	             <Grid>						
	                 <StackPanel Orientation="Horizontal" >						
	                     <Image Source="{Binding Name,Converter={StaticResource ncvt}}" Width="64" Height="64"/>						
	                     <TextBlock Text="{Binding ID}" Margin="10,10,5,10" Width="100"/>						
	                     <TextBlock Text="{Binding Name}" Margin="10,10,5,10" Width="100"/>						
	                     <TextBlock Text="{Binding Sex}" Margin="10,10,5,10" Width="50"/>						
	                     <TextBlock Text="{Binding Score}" Margin="10,10,5,10" Width="50"/>						
	                     <Image Source="{Binding Score,Converter={StaticResource scvt}}" Width="64" Height="64"/>						
	                 </StackPanel>						
	             </Grid>						
	         </DataTemplate>						
	    </ListBox.ItemTemplate>						
	</ListBox>						
							
	4 DataTemplate可以应用于哪些控件？						
	4.1 ContentControl控件（内容控件）						
	被ContentControl控件的Contemplate属性使用。						
	最常用的ContentControl控件包括：Button、ButtonBase、CheckBox、ComboBoxItem、Label、ListBoxItem、ListViewItem、RadioButton、ToolTip、UserControl、Window等。						
							
	4.2 ItemsControl控件（项控件）						
	被ItemsControl控件的ItemTemplate属性。						
	最常见的ItemsControl控件包括：Menu、MenuBase、ContextMenu、ComoBox、ListBox、ListView等。						
							
	4.3 被GridViewColumn控件的CellTemplate属性使用。						
							
	三 总结						
	本文通过实例演示了WPF中DatatTemplate的使用方法，并解释了：为什么要使用DatatTemplate以及DatatTemplate中数据绑定的实现原理等知识。						
							
控件之间绑定							
	实现一个按钮背景随着List的颜色选项变色。						
	<Window x:Class="WPFdemo5.MainWindow"						
	        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"						
	        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"						
	        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"						
	        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"						
	        xmlns:local="clr-namespace:WPFdemo5"						
	        mc:Ignorable="d"						
	        Title="MainWindow" Height="350" Width="525">						
	    <Grid>						
	        <ListBox x:Name="listBox" HorizontalAlignment="Left" Height="197" Margin="355,58,0,0" VerticalAlignment="Top" Width="127">						
	            <ListBoxItem Height="20" Tag="Red" Content="Red"/>						
	            <ListBoxItem Height="20" Tag="Blue" Content="Blue"/>						
	            <ListBoxItem Height="20" Tag="Green" Content="Green"/>						
							
	        </ListBox>						
	        <Button x:Name="button" Content="Button" HorizontalAlignment="Left" Margin="92,97,0,0"  						
	Background="{Binding ElementName=listBox,Path=SelectedItem.Tag ,Mode=OneWay}" VerticalAlignment="Top" Width="75" Height="80"/>						
	    </Grid>						
	</Window>						
	绑定的代码：						
	Background="{Binding ElementName=listBox,Path=SelectedItem.Tag ,Mode=OneWay}"						
	Binding 中 ElementName=listBox  绑定控件的Name，Path=SelectedItem.Tag  绑定控件的什么属性值，Mode=OneWay 绑定控件的方式						
	A,B两控件： A属性值绑定B属性值						
	TwoWay：双向绑定，两者之间，改一个动两者，B一直变，则A一直变；A一直变则B也一直变						
	OneWay ：单向绑定，B一直变，则A一直变						
	OneTime：单次绑定，B一直变，则A不一直变，只随着A初始值变一次						
	OneWayToSource：逆向绑定，A一直变，则B一直变						
	Default：默认，一般情况下用户可编辑控件属性（例如文本框和复选框的属性）默认为双向绑定，而多数其他属性默认为单向绑定。						
							
	后台代码绑定和解绑						
	            //声明和初始化绑定						
	            Binding b = new Binding();						
	            //绑定源，控件name						
	            b.Source = this.listBox;						
	            //绑定源的属性值						
	            b.Path = new PropertyPath("SelectedItem.Tag");						
	            //绑定方式						
	            b.Mode = BindingMode.OneWay;						
	            //要绑定控件的属性，绑定对象						
	            this.button.SetBinding(Button.BackgroundProperty, b);						
							
							
	            //删除绑定						
	            BindingOperations.ClearAllBindings(this.button);						
							
	


