## WPF基础
### Xbap	
Xbap是WPF的浏览器应用程序，可采用ClickOnce布署方式，并增加签名。

### WPF和WinForm的区别：									
	WPF没有类似WinForm的MDI主窗体，但我们可以自己定义。								
	WinForm继承于Form，而WPF的窗体继承于Window。								
									
### WPF中事件的使用：									
	1、修改图片设置所在类的文件：								
	//增加修改图片路径方法								
	        private void SetPicture(string coupler)								
	        {								
	            if (coupler.Equals("1"))								
	            {								
	                this.overviewpic.Source = new BitmapImage(new Uri("Images\\OverviewStatorSlot.jpg", UriKind.Relative));								
	            }								
	            else								
	            {								
	                this.overviewpic.Source = new BitmapImage(new Uri("Images\\Overview.jpg", UriKind.Relative));								
	            }								
	        }								
	//增加Coupler改变时启动线程调用【修改图片路径】方法								
	        public void CouplerChanged(object sender, CouplerChangedEventArgs args)								
	        {								
	            if (this.Dispatcher.Thread != Thread.CurrentThread)								
	            {								
	                this.Dispatcher.BeginInvoke(DispatcherPriority.Normal, new ThreadStart(() => this.SetPicture(args.Coupler)));								
	            }								
	            else								
	            {								
	                this.SetPicture(args.Coupler);								
	            }								
	        }								
	//增加Coupler改变时传递配置值数据的事件参数类。注：是与OverViewElement类平级的类，因为代码量小，不单独创建文件了。								
	public class CouplerChangedEventArgs : RoutedEventArgs								
	    {								
	        public string Coupler { get; set; }								
	    }								
									
	2、修改界面类（包含步骤1中的类对象）：								
	//新增方法								
	private void SetModuleCoupler(String planName, String unitName)								
	        {								
	            CareCentre cc = null;								
	            if (CareCentreManager.Instance.CareCentres.Values.Count > 0)								
	            {								
	                cc = CareCentreManager.Instance.CareCentres.Values.ToArray()[0];								
	                ModuleConfig config = ModuleHelper.GetConfig(cc, planName, unitName);								
	                CouplerChangedEventArgs args = new CouplerChangedEventArgs();								
	                args.Coupler = config.Coupler;								
	                overViewElement.CouplerChanged(null,args);								
	            }								
	        }								
	//修改CreateTagList方法，增加SetModuleCoupler方法调用								
	SetModuleCoupler(pducd.CurrentPlant.Name, pducd.CurrentUnit.Name); 								
									
### 关于绑定：									
	A,B两控件： A属性值绑定B属性值								
	TwoWay：双向绑定，两者之间，改一个动两者，B一直变，则A一直变；A一直变则B也一直变								
	OneWay ：单向绑定，B一直变，则A一直变								
	OneTime：单次绑定，B一直变，则A不一直变，只随着A初始值变一次								
	OneWayToSource：逆向绑定，A一直变，则B一直变								
	Default：默认，一般情况下用户可编辑控件属性（例如文本框和复选框的属性）默认为双向绑定，而多数其他属性默认为单向绑定。								
									
	WPF中Binding的几种写法								
	<!--绑定到DataContext-->								
	<Button Content="{Binding DataTime}"/>								
	 								
	<!--绑定到DataContext,并设置绑定模式-->								
	<Button x:Name="btn" Content="{Binding DataTime,Mode=OneTime}"/>								
	 								
	<!--绑定到DataContext,并设置更新模式-->								
	<Button Content="{Binding DataTime,UpdateSourceTrigger=PropertyChanged}"/>								
	 								
	<!--绑定到DataContext,并设置转换模式-->								
	<Button Content="{Binding DataTime,Converter={StaticResource ConvertResource},ConverterParameter=btn1}"/>								
	 								
	<!--绑定到Element中指定属性-->								
	<Button Content="{Binding ElementName=btn,Path=Content}"/>								
	 								
	<!--绑定到相对位置中的自身模式-->								
	<Button Content="{Binding RelativeSource={RelativeSource Mode=Self},Path=Tag}" Tag="MyTag"/>								
	 								
	<!--绑定到相对位置中的父级别查找模式-->								
	<Button Content="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorType=Window},Path=Content}"/>								
	 								
	<!--绑定到相对位置中的父级别查找模式 绑定到指定类型-->								
	<Button Content="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorType=Window},Path=Content}"/>								
	 								
	<!--绑定到相对位置中的父级别查找模式 绑定到指定层级-->								
	<Button Content="{Binding RelativeSource={RelativeSource Mode=FindAncestor,AncestorLevel=2},Path=Content}"/>								
	 								
	<!--绑定到相对位置中的父级别查找模式 绑定到模板内容-->								
	<Button Content="{Binding RelativeSource={RelativeSource Mode=TemplatedParent},Path=Content}"/>								

### 注：对WrapPanel，要设置背景色，才会使用设置显示的大小，要不会其大小由其内的所有控件共同决定。	
	
	
### 右键菜单显示有空白一级问题：	
	在界面中编辑的右键菜单，在运行显示后菜单为第二级，点击时还显示一个空白。
	在代码中生成右键菜单就没有这个问题。
	
### 桌面控件：
GroupBox下含一个WrapPanl，在没有控件的情况下。第一次加载显示充满。	
打开另一个控件，将桌面控件隐藏，该控件显示。再切回来桌面，发现桌面变小了。
如在上面的方法中，将桌面控件移出，切回来时再添加，就不会出现上述问题。

